> **ç‰ˆæœ¬**: 2.0  
> **é©ç”¨ç¯„åœ**: JavaScript, Python, Go, Java, C# ç­‰æ‰€æœ‰ä¸»æµèªè¨€  
> **ç›®æ¨™ä½¿ç”¨è€…**: æ¶æ§‹å¸«ã€è³‡æ·±å·¥ç¨‹å¸«ã€æŠ€è¡“ä¸»ç®¡

---

## ğŸ“‹ ç›®éŒ„

1. [å¿«é€Ÿé–‹å§‹](#å¿«é€Ÿé–‹å§‹)
2. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
3. [é‡æ§‹æ–¹æ³•è«–](#é‡æ§‹æ–¹æ³•è«–)
4. [æ¶æ§‹è¨­è¨ˆè¦ç¯„](#æ¶æ§‹è¨­è¨ˆè¦ç¯„)
5. [å¯¦ä½œæŒ‡å—](#å¯¦ä½œæŒ‡å—)
6. [æœ€ä½³å¯¦è¸](#æœ€ä½³å¯¦è¸)
7. [ç¯„ä¾‹èˆ‡æ¨¡æ¿](#ç¯„ä¾‹èˆ‡æ¨¡æ¿)
8. [å¸¸è¦‹å•é¡Œ](#å¸¸è¦‹å•é¡Œ)

---

## ğŸ¯ å¿«é€Ÿé–‹å§‹

### ä»€éº¼æ˜¯ Node-Based é‡æ§‹ï¼Ÿ

å°‡å‚³çµ±çš„æµç¨‹å¼ç¨‹å¼ç¢¼è½‰æ›ç‚º**ç¯€é»å¼å·¥ä½œæµç³»çµ±**ï¼Œæ¯å€‹æ¥­å‹™æ­¥é©Ÿæˆç‚ºç¨ç«‹çš„ç¯€é»ï¼Œå…·å‚™ï¼š
- âœ… **ç²¾ç¢ºéŒ¯èª¤å®šä½**ï¼šå¤±æ•—æ™‚çŸ¥é“ç¢ºåˆ‡ç¯€é»
- âœ… **æ•ˆèƒ½ç›£æ§**ï¼šè‡ªå‹•è¿½è¹¤æ¯å€‹æ­¥é©Ÿè€—æ™‚
- âœ… **å¯è¦–åŒ–æµç¨‹**ï¼šæ¥­å‹™é‚è¼¯ä¸€ç›®äº†ç„¶
- âœ… **æ˜“æ–¼æ¸¬è©¦**ï¼šç¯€é»ç¨ç«‹å¯æ¸¬
- âœ… **éˆæ´»æ“´å±•**ï¼šæ–°å¢æ­¥é©Ÿåªéœ€åŠ å…¥ç¯€é»

### 30 ç§’å¿«é€Ÿä½¿ç”¨

```bash
# æ­¥é©Ÿ 1: è¤‡è£½ä¸‹æ–¹çš„ Prompt
# æ­¥é©Ÿ 2: å°‡ä½ çš„åŸå§‹ç¨‹å¼ç¢¼è²¼åœ¨ Prompt å¾Œé¢
# æ­¥é©Ÿ 3: ç²å¾—é‡æ§‹å¾Œçš„ä¼æ¥­ç´šç¨‹å¼ç¢¼
```

### é©ç”¨å ´æ™¯åˆ¤æ–·

| âœ… **é©åˆé‡æ§‹** | âŒ **ä¸é©åˆé‡æ§‹** |
|---|---|
| API æœå‹™å¾Œç«¯ | ç´”æ¼”ç®—æ³•å¯¦ä½œ |
| è³‡æ–™è™•ç†ç®¡é“ | UI å…ƒä»¶ç¨‹å¼ç¢¼ |
| å·¥ä½œæµç¨‹å¼•æ“ | è³‡æ–™åº« Schema |
| æ‰¹æ¬¡è™•ç†ç³»çµ± | é…ç½®æª”æ¡ˆ |
| å¾®æœå‹™æ¶æ§‹ | å–®ç´” CRUD |

---

## ğŸ§© æ ¸å¿ƒæ¦‚å¿µ

### 1. ç¯€é» (Node) æ¶æ§‹å±¤ç´š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         æ‡‰ç”¨å±¤ (Application)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      å·¥ä½œæµå±¤ (Workflow Graph)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       ç¯€é»å±¤ (Node Classes)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      é‹è¡Œæ™‚ (Runtime Core)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. ç¯€é»é¡å‹ç³»çµ±

#### åŸºç¤ç¯€é»é¡å‹
- **BaseNode**: æ‰€æœ‰ç¯€é»çš„çˆ¶é¡åˆ¥ï¼Œæä¾›çµ±ä¸€ä»‹é¢
- **SequenceNode**: é †åºåŸ·è¡Œå¤šå€‹å­ç¯€é»
- **IfNode**: æ¢ä»¶åˆ†æ”¯ï¼ŒåŸ·è¡Œ then æˆ– else ç¯€é»
- **TryNode**: éŒ¯èª¤å®¹éŒ¯ï¼Œæä¾› fallback æ©Ÿåˆ¶

#### æ¥­å‹™ç¯€é»ç¯„ä¾‹
```javascript
// Before: å‚³çµ±å¯«æ³•
function processOrder(order) {
  validateOrder(order);
  calculatePrice(order);
  applyDiscount(order);
  createInvoice(order);
  sendEmail(order);
}

// After: Node-Based
const orderWorkflow = new SequenceNode("ProcessOrder", [
  new ValidateOrderNode(),
  new CalculatePriceNode(),
  new ApplyDiscountNode(),
  new CreateInvoiceNode(),
  new SendEmailNode()
]);
```

### 3. å¯è§€æ¸¬æ€§ (Observability) ä¸‰æ”¯æŸ±

#### ğŸ“Š Metrics (æŒ‡æ¨™)
- ç¯€é»åŸ·è¡Œæ™‚é–“
- æˆåŠŸ/å¤±æ•—ç‡
- ååé‡çµ±è¨ˆ

#### ğŸ“ Logs (æ—¥èªŒ)
- çµæ§‹åŒ–æ—¥èªŒæ ¼å¼
- å¤šå±¤ç´šæ§åˆ¶ (DEBUG/INFO/WARN/ERROR)
- å½©è‰²çµ‚ç«¯è¼¸å‡º

#### ğŸ” Traces (è¿½è¹¤)
- å®Œæ•´åŸ·è¡Œè·¯å¾‘
- éŒ¯èª¤å †ç–Šè¿½è¹¤
- åˆ†æ•£å¼è¿½è¹¤æ”¯æ´

---

## ğŸ”§ é‡æ§‹æ–¹æ³•è«–

### éšæ®µä¸€ï¼šåˆ†æèˆ‡è¦åŠƒ

#### 1.1 æµç¨‹è­˜åˆ¥æ¸…å–®
```text
â–¡ ä¸»è¦æ¥­å‹™æµç¨‹æ­¥é©Ÿ
â–¡ æ¢ä»¶åˆ†æ”¯é‚è¼¯
â–¡ éŒ¯èª¤è™•ç†æµç¨‹
â–¡ å¤–éƒ¨æœå‹™èª¿ç”¨
â–¡ è³‡æ–™è½‰æ›æ­¥é©Ÿ
```

#### 1.2 è¤‡é›œåº¦è©•ä¼°çŸ©é™£

| é‚è¼¯é¡å‹ | è™•ç†ç­–ç•¥ | ç¯„ä¾‹ |
|---------|---------|------|
| ç°¡å–®é †åºé‚è¼¯ | æ‹†åˆ†ç‚ºç¨ç«‹ç¯€é» | é©—è­‰â†’è™•ç†â†’å„²å­˜ |
| æ¢ä»¶åˆ†æ”¯ | ä½¿ç”¨ IfNode | if (isPremium) \{...\} |
| è¤‡é›œæ¼”ç®—æ³• | ä¿ç•™ç‚ºé»‘ç›’ç¯€é» | æ©Ÿå™¨å­¸ç¿’æ¨¡å‹æ¨è«– |
| å¤šé‡ fallback | ä½¿ç”¨ TryNode | API1 å¤±æ•—â†’API2â†’æœ¬åœ°å¿«å– |
| ç·Šå¯†è€¦åˆé‚è¼¯ | å°è£ç‚ºå–®ä¸€ç¯€é» | äº¤æ˜“è™•ç†+é¤˜é¡æ›´æ–° |

### éšæ®µäºŒï¼šç¯€é»è¨­è¨ˆ

#### 2.1 ç¯€é»ç²’åº¦åŸå‰‡

**âœ… æ‡‰è©²æ‹†åˆ†çš„å ´æ™¯ï¼š**
```javascript
// åŸå§‹ç¨‹å¼ç¢¼
async function handleRequest(req) {
  // 1. é©—è­‰è¼¸å…¥ - ç¨ç«‹ç¯€é»
  if (!req.body.email) throw new Error("Missing email");
  
  // 2. æŸ¥è©¢è³‡æ–™åº« - ç¨ç«‹ç¯€é»
  const user = await db.findUser(req.body.email);
  
  // 3. å‘¼å«å¤–éƒ¨ API - ç¨ç«‹ç¯€é»
  const profile = await fetchProfile(user.id);
  
  // 4. å»ºæ§‹å›æ‡‰ - ç¨ç«‹ç¯€é»
  return formatResponse(user, profile);
}
```

**âŒ ä¸æ‡‰æ‹†åˆ†çš„å ´æ™¯ï¼š**
```javascript
// è¤‡é›œçš„é™ç´šç­–ç•¥ - ä¿æŒç‚ºå–®ä¸€ç¯€é»
class LLMServiceWithFallback {
  async analyze(text) {
    // ä¿æŒé€™æ•´å€‹è¤‡é›œé‚è¼¯åœ¨ä¸€èµ·
    try {
      return await this.primaryLLM(text);
    } catch (e1) {
      try {
        return await this.secondaryLLM(text);
      } catch (e2) {
        return await this.localModel(text);
      }
    }
  }
}
```

#### 2.2 ç¯€é»å‘½åè¦ç¯„

```javascript
// âœ… å¥½çš„å‘½å
ValidateEventNode      // å‹•è© + åè© + Node
FetchUserDataNode     // æ¸…æ¥šè¡¨é”å‹•ä½œ
BuildResponseNode     // æ˜ç¢ºçš„ç›®çš„

// âŒ é¿å…çš„å‘½å
ProcessNode          // å¤ªæ¨¡ç³Š
Node1, Node2        // ç„¡æ„ç¾©
DoStuffNode        // ä¸å°ˆæ¥­
```

### éšæ®µä¸‰ï¼šå¯¦ä½œèˆ‡æ•´åˆ

#### 3.1 ç¯€é»å¯¦ä½œæª¢æŸ¥æ¸…å–®
```markdown
æ¯å€‹ç¯€é»å¿…é ˆåŒ…å«ï¼š
â–¡ æ˜ç¢ºçš„å–®ä¸€è·è²¬
â–¡ è¼¸å…¥/è¼¸å‡ºé¡å‹å®šç¾©
â–¡ éŒ¯èª¤è™•ç†é‚è¼¯
â–¡ æ—¥èªŒè¨˜éŒ„é»
â–¡ æ•ˆèƒ½é–¾å€¼è¨­å®š
â–¡ å–®å…ƒæ¸¬è©¦
```

#### 3.2 å·¥ä½œæµçµ„åˆæ¨¡å¼

```javascript
// æ¨¡å¼ 1: ç·šæ€§æµç¨‹
const linearFlow = new SequenceNode("Main", [
  nodeA, nodeB, nodeC
]);

// æ¨¡å¼ 2: æ¢ä»¶åˆ†æ”¯
const branchFlow = new SequenceNode("Main", [
  nodeA,
  new IfNode("CheckCondition", 
    (ctx, input) => input.isPremium,
    premiumNode,
    standardNode
  ),
  nodeC
]);

// æ¨¡å¼ 3: éŒ¯èª¤å®¹éŒ¯
const resilientFlow = new SequenceNode("Main", [
  nodeA,
  new TryNode("FetchData", [
    primaryAPINode,
    secondaryAPINode,
    cacheNode
  ]),
  nodeC
]);
```

---

## ğŸ“ æ¶æ§‹è¨­è¨ˆè¦ç¯„

### 1. æ ¸å¿ƒé¡åˆ¥è¨­è¨ˆ

```javascript
// ========== 1. Logger é¡åˆ¥ ==========
class Logger {
  constructor(options = {}) {
    this.level = options.level || 'INFO';
    this.colors = options.colors !== false;
    this.structured = options.structured || false;
  }
  
  // æ–¹æ³•ç°½å
  debug(nodeId, message, data) {}
  info(nodeId, message, data) {}
  warn(nodeId, message, data) {}
  error(nodeId, message, error, data) {}
}

// ========== 2. ExecutionTracer é¡åˆ¥ ==========
class ExecutionTracer {
  constructor() {
    this.spans = [];
    this.currentPath = [];
    this.errors = [];
  }
  
  // æ–¹æ³•ç°½å
  startSpan(nodeId) {}
  endSpan(nodeId, status, duration) {}
  recordError(nodeId, error) {}
  getSummary() {}
}

// ========== 3. NodeContext é¡åˆ¥ ==========
class NodeContext {
  constructor(dependencies) {
    this.logger = dependencies.logger;
    this.tracer = dependencies.tracer;
    this.config = dependencies.config;
    this.services = dependencies.services;
  }
}

// ========== 4. BaseNode é¡åˆ¥ ==========
class BaseNode {
  constructor(id, executor, options = {}) {
    this.id = id;
    this.executor = executor;
    this.options = {
      logInput: options.logInput || false,
      logOutput: options.logOutput || false,
      performanceThreshold: options.performanceThreshold || 1000,
      retryCount: options.retryCount || 0,
      timeout: options.timeout || 30000
    };
  }
  
  async run(ctx, input) {
    const startTime = Date.now();
    ctx.tracer.startSpan(this.id);
    
    try {
      // åŸ·è¡Œå‰æ—¥èªŒ
      ctx.logger.debug(this.id, "Starting execution", {
        inputKeys: this.options.logInput ? input : Object.keys(input)
      });
      
      // åŸ·è¡Œç¯€é»é‚è¼¯
      const output = await this.executor(ctx, input);
      
      // æ•ˆèƒ½è­¦å‘Š
      const duration = Date.now() - startTime;
      if (duration > this.options.performanceThreshold) {
        ctx.logger.warn(this.id, `Slow execution: ${duration}ms`);
      }
      
      // æˆåŠŸæ—¥èªŒ
      ctx.logger.info(this.id, "Completed successfully", {
        duration,
        outputKeys: this.options.logOutput ? output : Object.keys(output)
      });
      
      ctx.tracer.endSpan(this.id, 'success', duration);
      return output;
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      // éŒ¯èª¤å¢å¼·
      error.nodeId = this.id;
      error.executionPath = ctx.tracer.currentPath.join(' â†’ ');
      error.duration = duration;
      
      // è¨˜éŒ„éŒ¯èª¤
      ctx.logger.error(this.id, "Execution failed", error);
      ctx.tracer.recordError(this.id, error);
      ctx.tracer.endSpan(this.id, 'error', duration);
      
      throw error;
    }
  }
}
```

### 2. ç›£æ§å„€è¡¨æ¿è¦æ ¼

```html
<!-- ç›£æ§å„€è¡¨æ¿å¿…å‚™å…ƒç´  -->
<!DOCTYPE html>
<html>
<head>
  <title>Node Workflow Monitor</title>
  <style>
    /* è¦–è¦ºåŒ–æ¨£å¼ */
    .node-success { background: #4CAF50; }
    .node-error { background: #f44336; }
    .node-slow { background: #ff9800; }
  </style>
</head>
<body>
  <!-- 1. ç³»çµ±å¥åº·æŒ‡æ¨™ -->
  <div id="health-metrics">
    <div class="metric">æˆåŠŸç‡: <span id="success-rate">99.5%</span></div>
    <div class="metric">å¹³å‡éŸ¿æ‡‰: <span id="avg-response">245ms</span></div>
    <div class="metric">éŒ¯èª¤æ•¸: <span id="error-count">3</span></div>
  </div>
  
  <!-- 2. ç¯€é»åŸ·è¡Œè¦–è¦ºåŒ– -->
  <div id="node-visualization">
    <!-- å‹•æ…‹ç”Ÿæˆç¯€é»ç‹€æ…‹åœ– -->
  </div>
  
  <!-- 3. å³æ™‚æ—¥èªŒä¸²æµ -->
  <div id="log-stream">
    <!-- æœ€è¿‘ 20 æ¢æ—¥èªŒ -->
  </div>
  
  <!-- 4. æ•ˆèƒ½åˆ†æåœ–è¡¨ -->
  <canvas id="performance-chart"></canvas>
  
  <script>
    // å³æ™‚è³‡æ–™æ›´æ–°é‚è¼¯
    setInterval(fetchMetrics, 1000);
  </script>
</body>
</html>
```

### 3. API å›æ‡‰æ ¼å¼æ¨™æº–

```javascript
// æˆåŠŸå›æ‡‰
{
  "ok": true,
  "data": { /* æ¥­å‹™è³‡æ–™ */ },
  "executionSummary": {
    "traceId": "uuid-v4",
    "totalDuration": 2247,
    "totalNodes": 6,
    "successNodes": 6,
    "failedNodes": 0,
    "nodeMetrics": [
      {
        "nodeId": "ValidateInput",
        "status": "success",
        "duration": 12
      }
    ]
  }
}

// éŒ¯èª¤å›æ‡‰
{
  "ok": false,
  "error": {
    "code": "VALIDATION_FAILED",
    "message": "Email format invalid",
    "nodeId": "ValidateInput",
    "executionPath": "Main â†’ ValidateInput",
    "details": { /* éŒ¯èª¤è©³æƒ… */ }
  },
  "executionSummary": { /* åŒä¸Š */ }
}
```

---

## ğŸ› ï¸ å¯¦ä½œæŒ‡å—

### æ­¥é©Ÿ 1: ç’°å¢ƒæº–å‚™

```bash
# Node.js å°ˆæ¡ˆ
npm install ajv winston express

# Python å°ˆæ¡ˆ
pip install pydantic loguru fastapi

# Go å°ˆæ¡ˆ
go get github.com/sirupsen/logrus
```

### æ­¥é©Ÿ 2: å»ºç«‹åŸºç¤æ¶æ§‹

1. å»ºç«‹ `/core` ç›®éŒ„ï¼Œå¯¦ä½œæ ¸å¿ƒé¡åˆ¥
2. å»ºç«‹ `/nodes` ç›®éŒ„ï¼Œå­˜æ”¾æ¥­å‹™ç¯€é»
3. å»ºç«‹ `/workflows` ç›®éŒ„ï¼Œçµ„åˆå·¥ä½œæµ
4. å»ºç«‹ `/monitoring` ç›®éŒ„ï¼Œç›£æ§ç›¸é—œ

### æ­¥é©Ÿ 3: é‡æ§‹åŸæœ‰ç¨‹å¼ç¢¼

#### 3.1 è­˜åˆ¥ä¸¦æ¨™è¨˜
```javascript
// === STEP 1: è­˜åˆ¥æµç¨‹ ===
// [NODE] è¼¸å…¥é©—è­‰
// [NODE] è³‡æ–™æŸ¥è©¢
// [PRESERVE] è¤‡é›œæ¼”ç®—æ³•
// [NODE] çµæœæ ¼å¼åŒ–
```

#### 3.2 å»ºç«‹ç¯€é»
```javascript
// === STEP 2: å»ºç«‹ç¯€é» ===
const ValidateInputNode = new BaseNode(
  "ValidateInput",
  async (ctx, input) => {
    // åŸæœ‰é©—è­‰é‚è¼¯
  }
);
```

#### 3.3 çµ„åˆå·¥ä½œæµ
```javascript
// === STEP 3: çµ„åˆå·¥ä½œæµ ===
function makeMainWorkflow() {
  return new SequenceNode("MainWorkflow", [
    ValidateInputNode,
    QueryDataNode,
    ComplexAlgorithmNode, // ä¿ç•™çš„é»‘ç›’
    FormatResultNode
  ]);
}
```

### æ­¥é©Ÿ 4: æ•´åˆèˆ‡æ¸¬è©¦

```javascript
// Express æ•´åˆç¯„ä¾‹
app.post("/api/process", async (req, res) => {
  const workflow = makeMainWorkflow();
  const ctx = new NodeContext({
    logger: new Logger({ level: process.env.LOG_LEVEL }),
    tracer: new ExecutionTracer(),
    config: appConfig,
    services: { db, cache, messageQueue }
  });
  
  try {
    const result = await workflow.run(ctx, req.body);
    res.json({
      ok: true,
      data: result,
      executionSummary: ctx.tracer.getSummary()
    });
  } catch (error) {
    const statusCode = error.code === 'VALIDATION_ERROR' ? 400 : 500;
    res.status(statusCode).json({
      ok: false,
      error: {
        code: error.code,
        message: error.message,
        nodeId: error.nodeId,
        executionPath: error.executionPath
      },
      executionSummary: ctx.tracer.getSummary()
    });
  }
});
```

---

## ğŸ’¡ æœ€ä½³å¯¦è¸

### 1. ç¯€é»è¨­è¨ˆåŸå‰‡

| åŸå‰‡ | èªªæ˜ | ç¯„ä¾‹ |
|-----|------|------|
| **å–®ä¸€è·è²¬** | æ¯å€‹ç¯€é»åªåšä¸€ä»¶äº‹ | âœ… ValidateEmailNode<br />âŒ ValidateAndSendEmailNode |
| **ç„¡ç‹€æ…‹** | ç¯€é»ä¸æ‡‰ä¿å­˜ç‹€æ…‹ | ä½¿ç”¨ ctx å‚³éç‹€æ…‹ |
| **å†ªç­‰æ€§** | é‡è¤‡åŸ·è¡Œçµæœç›¸åŒ | é¿å…åœ¨ç¯€é»ä¸­ç´¯åŠ è¨ˆæ•¸ |
| **å¯æ¸¬è©¦** | ç¨ç«‹å¯æ¸¬ | é€é mock ctx æ¸¬è©¦ |

### 2. éŒ¯èª¤è™•ç†ç­–ç•¥

```javascript
// ç­–ç•¥ 1: å¿«é€Ÿå¤±æ•—
const strictNode = new BaseNode("Strict", async (ctx, input) => {
  if (!input.required) {
    throw new Error("Missing required field");
  }
});

// ç­–ç•¥ 2: å„ªé›…é™ç´š
const resilientNode = new BaseNode("Resilient", async (ctx, input) => {
  try {
    return await primaryService(input);
  } catch (error) {
    ctx.logger.warn("Resilient", "Primary failed, using fallback");
    return await fallbackService(input);
  }
});

// ç­–ç•¥ 3: éƒ¨åˆ†æˆåŠŸ
const partialNode = new BaseNode("Partial", async (ctx, input) => {
  const results = await Promise.allSettled([
    service1(input),
    service2(input),
    service3(input)
  ]);
  
  return {
    successful: results.filter(r => r.status === 'fulfilled'),
    failed: results.filter(r => r.status === 'rejected')
  };
});
```

### 3. æ•ˆèƒ½å„ªåŒ–æŠ€å·§

```javascript
// æŠ€å·§ 1: å¹³è¡ŒåŸ·è¡Œ
const parallelNode = new BaseNode("Parallel", async (ctx, input) => {
  const [result1, result2] = await Promise.all([
    fetchData1(input),
    fetchData2(input)
  ]);
  return { result1, result2 };
});

// æŠ€å·§ 2: å¿«å–ç­–ç•¥
const cachedNode = new BaseNode("Cached", async (ctx, input) => {
  const cacheKey = `node:${input.id}`;
  const cached = await ctx.services.cache.get(cacheKey);
  
  if (cached) {
    ctx.logger.debug("Cached", "Cache hit");
    return cached;
  }
  
  const result = await expensiveOperation(input);
  await ctx.services.cache.set(cacheKey, result, 3600);
  return result;
});

// æŠ€å·§ 3: æ‰¹æ¬¡è™•ç†
const batchNode = new BaseNode("Batch", async (ctx, input) => {
  const chunks = chunkArray(input.items, 100);
  const results = [];
  
  for (const chunk of chunks) {
    const batchResult = await processBatch(chunk);
    results.push(...batchResult);
  }
  
  return results;
});
```

### 4. ç›£æ§èˆ‡å‘Šè­¦è¨­å®š

```yaml
# monitoring-config.yaml
alerts:
  - name: high_error_rate
    condition: error_rate > 5%
    action: send_slack_notification
    
  - name: slow_node_execution
    condition: node_duration > 5000ms
    action: create_incident
    
  - name: memory_leak_detection
    condition: memory_usage_trend > 10MB/hour
    action: trigger_heap_dump
```

---

## ğŸ“š ç¯„ä¾‹èˆ‡æ¨¡æ¿

### å®Œæ•´ç¯„ä¾‹ï¼šè¨‚å–®è™•ç†ç³»çµ±

#### Before: å‚³çµ±å¯¦ä½œ
```javascript
async function processOrder(orderData) {
  try {
    // é©—è­‰è¨‚å–®
    if (!orderData.items || orderData.items.length === 0) {
      throw new Error("Order must have items");
    }
    
    // æª¢æŸ¥åº«å­˜
    for (const item of orderData.items) {
      const stock = await db.checkStock(item.productId);
      if (stock < item.quantity) {
        throw new Error(`Insufficient stock for ${item.productId}`);
      }
    }
    
    // è¨ˆç®—åƒ¹æ ¼
    let total = 0;
    for (const item of orderData.items) {
      const price = await db.getPrice(item.productId);
      total += price * item.quantity;
    }
    
    // æ‡‰ç”¨æŠ˜æ‰£
    if (orderData.couponCode) {
      const discount = await validateCoupon(orderData.couponCode);
      total = total * (1 - discount);
    }
    
    // å»ºç«‹è¨‚å–®
    const order = await db.createOrder({
      ...orderData,
      total,
      status: 'pending'
    });
    
    // ç™¼é€ç¢ºèªéƒµä»¶
    await emailService.sendOrderConfirmation(order);
    
    return order;
    
  } catch (error) {
    console.error("Order processing failed:", error);
    throw error;
  }
}
```

#### After: Node-Based å¯¦ä½œ
```javascript
// ===== 1. ç¯€é»å®šç¾© =====
const ValidateOrderNode = new BaseNode(
  "ValidateOrder",
  async (ctx, input) => {
    const { order } = input;
    
    if (!order.items || order.items.length === 0) {
      throw new ValidationError("Order must have items");
    }
    
    ctx.logger.info("ValidateOrder", "Order validated", {
      itemCount: order.items.length
    });
    
    return input;
  },
  { logInput: true }
);

const CheckInventoryNode = new BaseNode(
  "CheckInventory",
  async (ctx, input) => {
    const { order } = input;
    const inventoryChecks = [];
    
    for (const item of order.items) {
      const stock = await ctx.services.db.checkStock(item.productId);
      if (stock < item.quantity) {
        throw new BusinessError(
          `Insufficient stock for ${item.productId}`
        );
      }
      inventoryChecks.push({ 
        productId: item.productId, 
        available: stock 
      });
    }
    
    return { ...input, inventoryChecks };
  },
  { performanceThreshold: 2000 }
);

const CalculatePriceNode = new BaseNode(
  "CalculatePrice",
  async (ctx, input) => {
    const { order } = input;
    let subtotal = 0;
    
    const prices = await Promise.all(
      order.items.map(item => 
        ctx.services.db.getPrice(item.productId)
      )
    );
    
    order.items.forEach((item, idx) => {
      subtotal += prices[idx] * item.quantity;
    });
    
    return { ...input, subtotal };
  }
);

const ApplyDiscountNode = new BaseNode(
  "ApplyDiscount",
  async (ctx, input) => {
    const { order, subtotal } = input;
    let finalTotal = subtotal;
    
    if (order.couponCode) {
      try {
        const discount = await ctx.services.couponService
          .validateCoupon(order.couponCode);
        finalTotal = subtotal * (1 - discount);
        
        ctx.logger.info("ApplyDiscount", "Discount applied", {
          couponCode: order.couponCode,
          discount: `${discount * 100}%`
        });
      } catch (error) {
        ctx.logger.warn("ApplyDiscount", "Invalid coupon", {
          couponCode: order.couponCode
        });
      }
    }
    
    return { ...input, finalTotal };
  }
);

const CreateOrderNode = new BaseNode(
  "CreateOrder",
  async (ctx, input) => {
    const { order, finalTotal } = input;
    
    const createdOrder = await ctx.services.db.createOrder({
      ...order,
      total: finalTotal,
      status: 'pending',
      createdAt: new Date()
    });
    
    ctx.logger.info("CreateOrder", "Order created", {
      orderId: createdOrder.id,
      total: finalTotal
    });
    
    return { ...input, createdOrder };
  }
);

const SendConfirmationNode = new BaseNode(
  "SendConfirmation",
  async (ctx, input) => {
    const { createdOrder } = input;
    
    await ctx.services.emailService.sendOrderConfirmation(createdOrder);
    
    ctx.logger.info("SendConfirmation", "Email sent", {
      orderId: createdOrder.id,
      email: createdOrder.customerEmail
    });
    
    return { ...input, emailSent: true };
  },
  { retryCount: 3 }
);

// ===== 2. å·¥ä½œæµçµ„åˆ =====
function makeOrderProcessingWorkflow() {
  return new SequenceNode("OrderProcessing", [
    ValidateOrderNode,
    CheckInventoryNode,
    CalculatePriceNode,
    new IfNode(
      "HasCoupon",
      (ctx, input) => !!input.order.couponCode,
      ApplyDiscountNode,
      new BaseNode("SkipDiscount", async (ctx, input) => ({
        ...input,
        finalTotal: input.subtotal
      }))
    ),
    CreateOrderNode,
    new TryNode("Notification", [
      SendConfirmationNode,
      new BaseNode("LogNotificationFailure", async (ctx, input) => {
        ctx.logger.error("Notification", "Failed to send email");
        return { ...input, emailSent: false };
      })
    ])
  ]);
}

// ===== 3. API æ•´åˆ =====
app.post("/api/orders", async (req, res) => {
  const workflow = makeOrderProcessingWorkflow();
  
  const ctx = new NodeContext({
    logger: new Logger({ 
      level: process.env.LOG_LEVEL || 'INFO',
      structured: true 
    }),
    tracer: new ExecutionTracer(),
    services: {
      db: databaseService,
      emailService: emailService,
      couponService: couponService
    }
  });
  
  try {
    const result = await workflow.run(ctx, {
      order: req.body,
      metadata: {
        requestId: req.headers['x-request-id'],
        clientIp: req.ip
      }
    });
    
    res.status(201).json({
      ok: true,
      order: result.createdOrder,
      executionSummary: ctx.tracer.getSummary()
    });
    
  } catch (error) {
    const statusCode = 
      error instanceof ValidationError ? 400 :
      error instanceof BusinessError ? 422 : 500;
    
    res.status(statusCode).json({
      ok: false,
      error: {
        type: error.constructor.name,
        message: error.message,
        nodeId: error.nodeId,
        executionPath: error.executionPath,
        trace: ctx.tracer.getSummary()
      }
    });
    
    // è¨˜éŒ„åˆ°ç›£æ§ç³»çµ±
    ctx.logger.error("OrderProcessing", "Workflow failed", {
      error: error.message,
      nodeId: error.nodeId,
      requestId: req.headers['x-request-id']
    });
  }
});

// ===== 4. ç›£æ§ç«¯é» =====
app.get("/api/monitoring/health", (req, res) => {
  res.json({
    status: "healthy",
    metrics: getSystemMetrics(),
    timestamp: new Date()
  });
});

app.get("/api/monitoring/traces/:traceId", async (req, res) => {
  const trace = await getTraceById(req.params.traceId);
  res.json(trace);
});
```

---

## â“ å¸¸è¦‹å•é¡Œ

### Q1: ä»€éº¼æ™‚å€™ä¸æ‡‰è©²ä½¿ç”¨ Node-Based é‡æ§‹ï¼Ÿ

**A:** ä»¥ä¸‹æƒ…æ³ä¸é©åˆï¼š
- ç°¡å–®çš„ CRUD æ“ä½œï¼ˆéåº¦å·¥ç¨‹ï¼‰
- ç´”ç²¹çš„æ•¸å­¸è¨ˆç®—å‡½æ•¸
- UI æ¸²æŸ“é‚è¼¯
- å·²ç¶“å¾ˆæ¸…æ™°çš„å°å‹å‡½æ•¸

### Q2: å¦‚ä½•è™•ç†è³‡æ–™åº«äº‹å‹™ï¼Ÿ

**A:** ä½¿ç”¨ TransactionNode åŒ…è£ï¼š
```javascript
const TransactionNode = new BaseNode("Transaction", async (ctx, input) => {
  const tx = await ctx.services.db.beginTransaction();
  try {
    // åŸ·è¡Œå¤šå€‹è³‡æ–™åº«æ“ä½œ
    const result = await innerWorkflow.run(ctx, input);
    await tx.commit();
    return result;
  } catch (error) {
    await tx.rollback();
    throw error;
  }
});
```

### Q3: å¦‚ä½•è™•ç†å¤§é‡è³‡æ–™ï¼Ÿ

**A:** ä½¿ç”¨ä¸²æµå’Œæ‰¹æ¬¡è™•ç†ï¼š
```javascript
const StreamProcessNode = new BaseNode("StreamProcess", async (ctx, input) => {
  const stream = ctx.services.db.streamLargeDataset();
  const batch = [];
  
  for await (const record of stream) {
    batch.push(record);
    
    if (batch.length >= 1000) {
      await processBatch(batch);
      batch.length = 0;
    }
  }
  
  if (batch.length > 0) {
    await processBatch(batch);
  }
});
```

### Q4: å¦‚ä½•é€²è¡Œå–®å…ƒæ¸¬è©¦ï¼Ÿ

**A:** æ¯å€‹ç¯€é»ç¨ç«‹æ¸¬è©¦ï¼š
```javascript
describe('ValidateOrderNode', () => {
  it('should validate order with items', async () => {
    const mockCtx = {
      logger: { info: jest.fn(), debug: jest.fn() },
      tracer: { startSpan: jest.fn(), endSpan: jest.fn() }
    };
    
    const input = {
      order: { items: [{ productId: '123', quantity: 1 }] }
    };
    
    const result = await ValidateOrderNode.run(mockCtx, input);
    expect(result).toEqual(input);
  });
  
  it('should throw on empty order', async () => {
    const mockCtx = { /* ... */ };
    const input = { order: { items: [] } };
    
    await expect(ValidateOrderNode.run(mockCtx, input))
      .rejects.toThrow('Order must have items');
  });
});
```

### Q5: å¦‚ä½•è™•ç†é•·æ™‚é–“åŸ·è¡Œçš„ä»»å‹™ï¼Ÿ

**A:** ä½¿ç”¨éåŒæ­¥ä»»å‹™éšŠåˆ—ï¼š
```javascript
const QueueTaskNode = new BaseNode("QueueTask", async (ctx, input) => {
  // å°‡ä»»å‹™åŠ å…¥éšŠåˆ—
  const taskId = await ctx.services.queue.enqueue({
    type: 'long-running-task',
    payload: input
  });
  
  // ç«‹å³è¿”å›ä»»å‹™ ID
  return { 
    taskId, 
    status: 'queued',
    checkUrl: `/api/tasks/${taskId}/status`
  };
});
```

---

## ğŸ“ å®Œæ•´ Prompt æ¨¡æ¿

ä»¥ä¸‹æ˜¯ä½ å¯ä»¥ç›´æ¥ä½¿ç”¨çš„å®Œæ•´é‡æ§‹ Promptï¼š

```text
# Node-Based æ¶æ§‹é‡æ§‹è«‹æ±‚

è«‹å°‡ä»¥ä¸‹ç¨‹å¼ç¢¼é‡æ§‹ç‚º Node-Based æ¶æ§‹ï¼Œå¿…é ˆåŒ…å«ï¼š

## æ ¸å¿ƒè¦æ±‚
1. **ç¯€é»ç³»çµ±**ï¼šBaseNode, SequenceNode, IfNode, TryNode
2. **å¯è§€æ¸¬æ€§**ï¼šLogger, ExecutionTracer, çµæ§‹åŒ–æ—¥èªŒ
3. **éŒ¯èª¤è¿½è¹¤**ï¼šç²¾ç¢ºçš„ nodeId å’ŒåŸ·è¡Œè·¯å¾‘
4. **æ•ˆèƒ½ç›£æ§**ï¼šè‡ªå‹•è¨˜éŒ„åŸ·è¡Œæ™‚é–“å’Œæ•ˆèƒ½è­¦å‘Š

## é‡æ§‹åŸå‰‡
1. è­˜åˆ¥ä¸¦æ‹†åˆ†ç¨ç«‹çš„æ¥­å‹™æ­¥é©Ÿç‚ºç¯€é»
2. ä¿ç•™è¤‡é›œæ¼”ç®—æ³•ç‚ºé»‘ç›’ï¼ˆåŠ è¨»è§£èªªæ˜ï¼‰
3. ä½¿ç”¨ IfNode è™•ç†æ¢ä»¶åˆ†æ”¯
4. ä½¿ç”¨ TryNode è™•ç†éŒ¯èª¤å®¹éŒ¯

## è¼¸å‡ºè¦æ±‚
1. å®Œæ•´å¯åŸ·è¡Œçš„ç¨‹å¼ç¢¼
2. åŒ…å«ç›£æ§å„€è¡¨æ¿ HTML
3. API æ•´åˆç¯„ä¾‹
4. ç’°å¢ƒè®Šæ•¸é…ç½®èªªæ˜
5. å–®å…ƒæ¸¬è©¦ç¯„ä¾‹

## åŸå§‹ç¨‹å¼ç¢¼
[åœ¨é€™è£¡è²¼ä¸Šä½ çš„ç¨‹å¼ç¢¼]
```

---

## ğŸš€ ä¸‹ä¸€æ­¥è¡Œå‹•

1. **è©•ä¼°ç¾æœ‰ç³»çµ±**ï¼šä½¿ç”¨é©ç”¨å ´æ™¯åˆ¤æ–·è¡¨è©•ä¼°æ˜¯å¦éœ€è¦é‡æ§‹
2. **é¸æ“‡è©¦é»å°ˆæ¡ˆ**ï¼šå¾å°å‹ã€éé—œéµç³»çµ±é–‹å§‹
3. **é€æ­¥å¯¦æ–½**ï¼šæŒ‰ç…§å¯¦ä½œæŒ‡å—åˆ†éšæ®µé€²è¡Œ
4. **ç›£æ§æ•ˆæœ**ï¼šä½¿ç”¨å„€è¡¨æ¿è¿½è¹¤æ”¹å–„æŒ‡æ¨™
5. **æ¨å»£ç¶“é©—**ï¼šå°‡æˆåŠŸç¶“é©—æ¨å»£åˆ°å…¶ä»–ç³»çµ±

---

## ğŸ“š å»¶ä¼¸é–±è®€

- [Clean Architecture åŸå‰‡](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Microservices Patterns](https://microservices.io/patterns/)
- [Observability Engineering](https://www.honeycomb.io/blog/observability-engineering-book)
- [Site Reliability Engineering](https://sre.google/books/)

---

## ğŸ¤ è²¢ç»æŒ‡å—

æ­¡è¿æäº¤æ”¹é€²å»ºè­°ï¼è«‹éµå¾ªä»¥ä¸‹åŸå‰‡ï¼š
- ä¿æŒç¯„ä¾‹çš„å¯¦ç”¨æ€§å’Œå¯åŸ·è¡Œæ€§
- æ–°å¢å…§å®¹éœ€åŒ…å«å…·é«”ç¯„ä¾‹
- ç¢ºä¿æ–‡æª”çµæ§‹æ¸…æ™°ã€æ˜“æ–¼é–±è®€

---

**æœ€å¾Œæ›´æ–°**: 2025-09  
**ç¶­è­·è€…**: Ian Chou  
**æˆæ¬Š**: MIT License