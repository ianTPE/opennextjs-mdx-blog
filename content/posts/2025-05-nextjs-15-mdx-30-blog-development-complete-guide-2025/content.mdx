åœ¨ç¾ä»£å‰ç«¯é–‹ç™¼ä¸­ï¼ŒNext.js çµåˆ MDX å·²æˆç‚ºå»ºç«‹æŠ€è¡“éƒ¨è½æ ¼çš„ä¸»æµé¸æ“‡ã€‚æœ¬æ–‡å°‡æ·±å…¥å‰–æå¾åˆ†æ•£å¼ ESM metadataã€local components åˆ°æœ€çµ‚ blog é é¢çš„å®Œæ•´è½‰æ›æµç¨‹ï¼Œä»¥å¯¦éš›å°ˆæ¡ˆæ¶æ§‹ç‚ºä¾‹ï¼Œé€æ­¥æ‹†è§£æ¯å€‹ç’°ç¯€çš„æŠ€è¡“ç´°ç¯€ã€‚æˆ‘å€‘å°‡é‡é»æ¢è¨å¦‚ä½•ä½¿ç”¨ MDX æª”æ¡ˆé ‚éƒ¨çš„ ESM export ä¾†ç®¡ç† metadataï¼Œé€™ç¨®æ–¹å¼ç›¸æ¯”é›†ä¸­å¼ç®¡ç†æä¾›äº†æ›´å¥½çš„å…§å®¹å…§èšæ€§èˆ‡é–‹ç™¼é«”é©—ã€‚

## ç›®éŒ„

1. [å°ˆæ¡ˆæ¶æ§‹æ¦‚è¦½](#å°ˆæ¡ˆæ¶æ§‹æ¦‚è¦½)
2. [ESM Metadata ç®¡ç†ç­–ç•¥](#esm-metadata-ç®¡ç†ç­–ç•¥)
3. [æª”æ¡ˆèˆ‡è³‡æ–™ä¾†æº](#æª”æ¡ˆèˆ‡è³‡æ–™ä¾†æº)
4. [å…§å®¹è®€å–èˆ‡è§£ææ©Ÿåˆ¶](#å…§å®¹è®€å–èˆ‡è§£ææ©Ÿåˆ¶)
5. [éœæ…‹è·¯ç”±ç”¢ç”Ÿæµç¨‹](#éœæ…‹è·¯ç”±ç”¢ç”Ÿæµç¨‹)
6. [MDX æ¸²æŸ“èˆ‡çµ„ä»¶æ•´åˆ](#mdx-æ¸²æŸ“èˆ‡çµ„ä»¶æ•´åˆ)
7. [é é¢çµ„åˆèˆ‡æœ€çµ‚å‘ˆç¾](#é é¢çµ„åˆèˆ‡æœ€çµ‚å‘ˆç¾)
8. [å®Œæ•´æ•¸æ“šæµç¤ºä¾‹](#å®Œæ•´æ•¸æ“šæµç¤ºä¾‹)
9. [é€²éšå„ªåŒ–èˆ‡æœ€ä½³å¯¦è¸](#é€²éšå„ªåŒ–èˆ‡æœ€ä½³å¯¦è¸)

## å°ˆæ¡ˆæ¶æ§‹æ¦‚è¦½

æœ¬å°ˆæ¡ˆæ¡ç”¨ Next.js 15+ App Router æ¶æ§‹ï¼Œçµåˆ MDX 3.1.0 é€²è¡Œå…§å®¹ç®¡ç†ï¼Œä¸¦ä½¿ç”¨åˆ†æ•£å¼ ESM metadata ç®¡ç†ç­–ç•¥ã€‚æ ¸å¿ƒæŠ€è¡“æ£§åŒ…æ‹¬ï¼š

- **Next.js 15.3.2** with App Router
- **React 19.0.0** 
- **MDX 3.1.0** for content with ESM metadata
- **TypeScript** for type safety
- **Tailwind CSS v4** for styling
- **next-mdx-remote** for dynamic MDX rendering

### æ ¸å¿ƒæª”æ¡ˆçµæ§‹

```
â”œâ”€â”€ app/
â”‚   â””â”€â”€ blog/
â”‚       â””â”€â”€ [slug]/
â”‚           â”œâ”€â”€ page.tsx              # ä¸»è¦æ–‡ç« é é¢é‚è¼¯
â”‚           â””â”€â”€ MDXRenderer.tsx       # å®¢æˆ¶ç«¯ MDX æ¸²æŸ“çµ„ä»¶
â”œâ”€â”€ content/
â”‚   â””â”€â”€ posts/
â”‚       â””â”€â”€ [slug]/
â”‚           â”œâ”€â”€ content.mdx           # æ–‡ç« å…§å®¹ + ESM metadata
â”‚           â””â”€â”€ components/           # æ–‡ç« å°ˆç”¨çµ„ä»¶
â”‚               â”œâ”€â”€ index.ts          # çµ„ä»¶åŒ¯å‡ºæª”
â”‚               â”œâ”€â”€ CustomChart.tsx
â”‚               â””â”€â”€ ...
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ mdx.ts                        # MDX è™•ç†æ ¸å¿ƒå‡½æ•¸
â”‚   â”œâ”€â”€ mdx-loader.ts                 # çµ„ä»¶è¼‰å…¥é‚è¼¯
â”‚   â””â”€â”€ metadata-extractor.ts        # ESM metadata æå–å·¥å…·
â””â”€â”€ components/
    â”œâ”€â”€ BlogPostContent.static.tsx    # éœæ…‹é é¢å¸ƒå±€
    â””â”€â”€ mdx/
        â””â”€â”€ global-components/        # å…¨åŸŸ MDX çµ„ä»¶
```

## ESM Metadata ç®¡ç†ç­–ç•¥

### 1. åˆ†æ•£å¼ ESM Metadata çš„å„ªå‹¢

ç›¸è¼ƒæ–¼é›†ä¸­å¼ç®¡ç†ï¼ŒESM metadata æä¾›ä»¥ä¸‹å„ªå‹¢ï¼š

- **å…§å®¹å…§èšæ€§**ï¼šmetadata èˆ‡å…§å®¹ä½æ–¼åŒä¸€æª”æ¡ˆï¼Œä¾¿æ–¼ç¶­è­·
- **å‹åˆ¥å®‰å…¨**ï¼šæ¯å€‹æª”æ¡ˆçš„ metadata éƒ½æœ‰å®Œæ•´çš„ TypeScript æ”¯æ´
- **ç‰ˆæœ¬æ§åˆ¶å‹å–„**ï¼šmetadata ä¿®æ”¹èˆ‡å…§å®¹ä¿®æ”¹åœ¨åŒä¸€å€‹ commit ä¸­
- **ç¨ç«‹æ€§**ï¼šæ¯ç¯‡æ–‡ç« å¯ä»¥ç¨ç«‹ç®¡ç†ï¼Œä¸æœƒäº’ç›¸å½±éŸ¿
- **æ“´å±•æ€§**ï¼šå®¹æ˜“æ–°å¢æ–‡ç« å°ˆç”¨çš„ metadata æ¬„ä½

### 2. MDX æª”æ¡ˆçš„ ESM Metadata çµæ§‹

æ¯å€‹ MDX æª”æ¡ˆçš„é ‚éƒ¨ä½¿ç”¨ ESM export å®šç¾© metadataï¼š

```mdx
// content/posts/nextjs-mdx-setup/content.mdx

# Next.js + MDX éƒ¨è½æ ¼å»ºç½®æŒ‡å—

å»ºç«‹ç¾ä»£åŒ–çš„æŠ€è¡“éƒ¨è½æ ¼éœ€è¦è€ƒæ…®å¤šå€‹é¢å‘...

## æ•ˆèƒ½åˆ†æ

ä»¥ä¸‹æ˜¯ä¸åŒæ¡†æ¶çš„æ•ˆèƒ½æ¯”è¼ƒï¼š

<PerformanceChart 
  data={performanceData} 
  title="Framework Performance Comparison" 
/>
```

### 3. Metadata å‹åˆ¥å®šç¾©

```typescript
// lib/types.ts
export interface BlogMetadata {
  title: string;
  date: string;
  author: string;
  excerpt: string;
  tags: string[];
  coverImage?: string;
  readingTime: number;
  featured?: boolean;
  category?: string;
  updatedDate?: string;
  seoKeywords?: string[];
  canonicalUrl?: string;
}

export interface BlogPost extends BlogMetadata {
  slug: string;
}

export interface PostWithContent {
  metadata: BlogMetadata;
  content: string;
  rawContent: string; // åŒ…å« metadata export çš„åŸå§‹å…§å®¹
}
```

## æª”æ¡ˆèˆ‡è³‡æ–™ä¾†æº

### 1. MDX å…§å®¹çµæ§‹

æ¯ç¯‡æ–‡ç« çš„çµæ§‹ä¿æŒä¸€è‡´ï¼Œmetadata ç›´æ¥åœ¨æª”æ¡ˆé ‚éƒ¨å®šç¾©ï¼š

```
content/posts/nextjs-mdx-setup/
â”œâ”€â”€ content.mdx                 # ä¸»è¦æ–‡ç« å…§å®¹ + ESM metadata
â””â”€â”€ components/                 # æ–‡ç« å°ˆç”¨çµ„ä»¶
    â”œâ”€â”€ index.ts               # çµ„ä»¶åŒ¯å‡ºæª”
    â”œâ”€â”€ PerformanceChart.tsx   # æ•ˆèƒ½åœ–è¡¨çµ„ä»¶
    â””â”€â”€ CodeComparison.tsx     # ç¨‹å¼ç¢¼æ¯”è¼ƒçµ„ä»¶
```

### 2. ESM Metadata æå–æ©Ÿåˆ¶

æˆ‘å€‘éœ€è¦å»ºç«‹å°ˆé–€çš„å·¥å…·ä¾†æå– MDX æª”æ¡ˆä¸­çš„ ESM metadataï¼š

```typescript
// lib/metadata-extractor.ts
import { compile } from '@mdx-js/mdx';
import { VFile } from 'vfile';

/**
 * å¾ MDX å…§å®¹ä¸­æå– ESM metadata
 */
export async function extractMetadataFromMDX(content: string): Promise<{
  metadata: any;
  cleanContent: string;
}> {
  try {
    // ä½¿ç”¨æ­£å‰‡è¡¨é”å¼æå– export const metadata
    const metadataRegex = /^export\s+const\s+metadata\s*=\s*({[\s\S]*?});/m;
    const match = content.match(metadataRegex);
    
    if (!match) {
      throw new Error('No metadata export found in MDX file');
    }

    const metadataString = match[1];
    const cleanContent = content.replace(metadataRegex, '').trim();

    // å®‰å…¨åœ°è©•ä¼° metadata å°è±¡
    const metadata = evaluateMetadataObject(metadataString);

    return {
      metadata,
      cleanContent
    };
  } catch (error) {
    console.error('Error extracting metadata:', error);
    throw error;
  }
}

/**
 * å®‰å…¨åœ°è©•ä¼° metadata å°è±¡
 */
function evaluateMetadataObject(metadataString: string): any {
  try {
    // å»ºç«‹ä¸€å€‹å®‰å…¨çš„è©•ä¼°ç’°å¢ƒ
    const evalFunction = new Function(`return ${metadataString}`);
    return evalFunction();
  } catch (error) {
    console.error('Error evaluating metadata object:', error);
    throw new Error('Invalid metadata object syntax');
  }
}

/**
 * é©—è­‰ metadata æ ¼å¼
 */
export function validateMetadata(metadata: any): BlogMetadata {
  const required = ['title', 'date', 'author', 'excerpt'];
  
  for (const field of required) {
    if (!metadata[field]) {
      throw new Error(`Missing required metadata field: ${field}`);
    }
  }

  // ç¢ºä¿ tags æ˜¯é™£åˆ—
  if (metadata.tags && !Array.isArray(metadata.tags)) {
    throw new Error('Tags must be an array');
  }

  // ç¢ºä¿ date æ ¼å¼æ­£ç¢º
  if (isNaN(Date.parse(metadata.date))) {
    throw new Error('Invalid date format');
  }

  return metadata as BlogMetadata;
}
```

### 3. Local Components æ¶æ§‹

çµ„ä»¶æ¶æ§‹ä¿æŒä¸è®Šï¼Œæ¯ç¯‡æ–‡ç« å¯ä»¥æ“æœ‰å°ˆå±¬çš„ React çµ„ä»¶ï¼š

```typescript
// content/posts/nextjs-mdx-setup/components/index.ts
"use client";

import PerformanceChart from './PerformanceChart';
import CodeComparison from './CodeComparison';
import InteractiveDemo from './InteractiveDemo';

export {
  PerformanceChart,
  CodeComparison,
  InteractiveDemo
};
```

## å…§å®¹è®€å–èˆ‡è§£ææ©Ÿåˆ¶

### 1. æ ¸å¿ƒè®€å–å‡½æ•¸

**getAllPostSlugs - æƒææ‰€æœ‰æ–‡ç« ç›®éŒ„**

```typescript
// lib/mdx.ts
import fs from 'fs';
import path from 'path';

const postsDirectory = path.join(process.cwd(), 'content', 'posts');

export function getAllPostSlugs(): string[] {
  try {
    const entries = fs.readdirSync(postsDirectory, { withFileTypes: true });
    
    return entries
      .filter(entry => entry.isDirectory())
      .map(entry => entry.name)
      .filter(slug => {
        // ç¢ºèªæ¯å€‹ç›®éŒ„éƒ½æœ‰ content.mdx æª”æ¡ˆ
        const mdxPath = path.join(postsDirectory, slug, 'content.mdx');
        return fs.existsSync(mdxPath);
      });
  } catch (error) {
    console.error('Error reading posts directory:', error);
    return [];
  }
}
```

**getPostBySlug - å–å¾—å®Œæ•´æ–‡ç« è³‡æ–™èˆ‡ metadata**

```typescript
export async function getPostBySlug(slug: string): Promise<PostWithContent | null> {
  try {
    const fullPath = path.join(postsDirectory, slug, 'content.mdx');
    
    if (!fs.existsSync(fullPath)) {
      console.warn(`MDX file not found: ${fullPath}`);
      return null;
    }

    // è®€å– MDX æª”æ¡ˆå…§å®¹
    const rawContent = fs.readFileSync(fullPath, 'utf8');

    // æå– metadata å’Œæ¸…ç†å¾Œçš„å…§å®¹
    const { metadata, cleanContent } = await extractMetadataFromMDX(rawContent);
    
    // é©—è­‰ metadata æ ¼å¼
    const validatedMetadata = validateMetadata(metadata);

    return {
      metadata: validatedMetadata,
      content: cleanContent,
      rawContent
    };
  } catch (error) {
    console.error(`Error reading post ${slug}:`, error);
    return null;
  }
}
```

**getAllPosts - å–å¾—æ‰€æœ‰æ–‡ç« åˆ—è¡¨**

```typescript
export async function getAllPosts(): Promise<BlogPost[]> {
  const slugs = getAllPostSlugs();
  
  const posts = await Promise.all(
    slugs.map(async (slug) => {
      const post = await getPostBySlug(slug);
      if (!post) return null;
      
      return { slug, ...post.metadata };
    })
  );

  const validPosts = posts.filter((post): post is BlogPost => post !== null);

  // æŒ‰æ—¥æœŸæ’åºï¼Œæœ€æ–°çš„åœ¨å‰
  return validPosts.sort((a, b) => {
    return new Date(b.date).getTime() - new Date(a.date).getTime();
  });
}
```

### 2. å¿«å–æ©Ÿåˆ¶

ç‚ºäº†æå‡æ•ˆèƒ½ï¼Œæˆ‘å€‘å¯ä»¥åŠ å…¥è¨˜æ†¶é«”å¿«å–ï¼š

```typescript
// lib/mdx-cache.ts
class MDXCache {
  private cache = new Map<string, PostWithContent>();
  private metadataCache = new Map<string, BlogMetadata>();

  async getPost(slug: string): Promise<PostWithContent | null> {
    if (this.cache.has(slug)) {
      return this.cache.get(slug)!;
    }

    const post = await getPostBySlug(slug);
    if (post) {
      this.cache.set(slug, post);
      this.metadataCache.set(slug, post.metadata);
    }

    return post;
  }

  async getMetadata(slug: string): Promise<BlogMetadata | null> {
    if (this.metadataCache.has(slug)) {
      return this.metadataCache.get(slug)!;
    }

    const post = await this.getPost(slug);
    return post ? post.metadata : null;
  }

  clear(): void {
    this.cache.clear();
    this.metadataCache.clear();
  }

  // é–‹ç™¼ç’°å¢ƒä¸‹å¯ä»¥æ¸…é™¤å¿«å–
  clearInDevelopment(): void {
    if (process.env.NODE_ENV === 'development') {
      this.clear();
    }
  }
}

export const mdxCache = new MDXCache();
```

### 3. Local Components è¼‰å…¥æ©Ÿåˆ¶

çµ„ä»¶è¼‰å…¥é‚è¼¯ä¿æŒä¸è®Šï¼š

```typescript
// lib/mdx-loader.ts
export async function getPostComponents(slug: string): Promise<Record<string, any>> {
  try {
    const componentsPath = path.join(postsDirectory, slug, 'components');
    
    if (!fs.existsSync(componentsPath)) {
      return {};
    }

    const indexPath = path.join(componentsPath, 'index.ts');
    
    if (!fs.existsSync(indexPath)) {
      return {};
    }

    // å‹•æ…‹ import çµ„ä»¶
    const components = await import(indexPath);
    return components;
  } catch (error) {
    console.warn(`Failed to load components for ${slug}:`, error);
    return {};
  }
}
```

## éœæ…‹è·¯ç”±ç”¢ç”Ÿæµç¨‹

### 1. generateStaticParams - ç”¢ç”Ÿæ‰€æœ‰æ–‡ç« è·¯å¾‘

```typescript
// app/blog/[slug]/page.tsx
export async function generateStaticParams() {
  const posts = await getAllPosts();
  
  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

### 2. generateMetadata - ç”¢ç”Ÿ SEO metadata

```typescript
export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const resolvedParams = await params;
  const post = await getPostBySlug(resolvedParams.slug);

  if (!post) {
    return {
      title: 'Post Not Found',
    };
  }

  const { metadata } = post;

  return {
    title: metadata.title,
    description: metadata.excerpt,
    keywords: metadata.seoKeywords ? metadata.seoKeywords.join(', ') : metadata.tags.join(', '),
    authors: [{ name: metadata.author }],
    canonical: metadata.canonicalUrl,
    openGraph: {
      title: metadata.title,
      description: metadata.excerpt,
      type: 'article',
      publishedTime: metadata.date,
      modifiedTime: metadata.updatedDate,
      authors: [metadata.author],
      tags: metadata.tags,
      images: metadata.coverImage ? [
        {
          url: metadata.coverImage,
          width: 1200,
          height: 630,
          alt: metadata.title,
        }
      ] : [],
    },
    twitter: {
      card: 'summary_large_image',
      title: metadata.title,
      description: metadata.excerpt,
      images: metadata.coverImage ? [metadata.coverImage] : [],
    },
  };
}
```

## MDX æ¸²æŸ“èˆ‡çµ„ä»¶æ•´åˆ

### 1. MDXRenderer - å®¢æˆ¶ç«¯ MDX æ¸²æŸ“å™¨

```typescript
// app/blog/[slug]/MDXRenderer.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote';
import { serialize } from 'next-mdx-remote/serialize';
import globalComponents from '@/components/mdx/MDXComponents';

interface MDXRendererProps {
  source: string;
  components?: Record<string, any>;
}

export default function MDXRenderer({ source, components = {} }: MDXRendererProps) {
  const [mdxSource, setMdxSource] = useState<MDXRemoteSerializeResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  // åˆä½µå…¨åŸŸçµ„ä»¶èˆ‡æœ¬åœ°çµ„ä»¶ï¼ˆæœ¬åœ°çµ„ä»¶å„ªå…ˆï¼‰
  const mergedComponents = {
    ...globalComponents,
    ...components,
  };

  useEffect(() => {
    const processMDX = async () => {
      try {
        const serialized = await serialize(source, {
          parseFrontmatter: false, // æˆ‘å€‘å·²ç¶“åœ¨ä¼ºæœå™¨ç«¯è™•ç†é metadata
          mdxOptions: {
            development: process.env.NODE_ENV === 'development',
          },
        });
        
        setMdxSource(serialized);
        setError(null);
      } catch (err) {
        console.error('MDX processing error:', err);
        setError('MDX å…§å®¹è™•ç†éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥èªæ³•æ˜¯å¦æ­£ç¢ºã€‚');
      }
    };

    if (source) {
      processMDX();
    }
  }, [source]);

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <p className="text-red-800">{error}</p>
      </div>
    );
  }

  if (!mdxSource) {
    return (
      <div className="flex items-center justify-center py-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        <span className="ml-2 text-gray-600">è¼‰å…¥ä¸­...</span>
      </div>
    );
  }

  return <MDXRemote {...mdxSource} components={mergedComponents} />;
}
```

### 2. å…¨åŸŸèˆ‡å€åŸŸçµ„ä»¶åˆä½µæ©Ÿåˆ¶

çµ„ä»¶å„ªå…ˆç´šé †åºä¿æŒä¸è®Šï¼š
1. **Local Components** (æœ€é«˜å„ªå…ˆç´š) - æ–‡ç« å°ˆç”¨çµ„ä»¶
2. **Global Components** - å…¨ç«™å…±ç”¨çµ„ä»¶

```typescript
// components/mdx/MDXComponents.tsx
import CodeBlock from './global-components/CodeBlock';
import Alert from './global-components/Alert';
import Mermaid from './global-components/Mermaid';

const globalComponents = {
  // è¦†è“‹é è¨­ HTML å…ƒç´ 
  h1: (props: any) => <h1 className="text-3xl font-bold mt-8 mb-4" {...props} />,
  h2: (props: any) => <h2 className="text-2xl font-semibold mt-6 mb-3" {...props} />,
  p: (props: any) => <p className="mb-4 leading-relaxed" {...props} />,
  
  // è‡ªè¨‚çµ„ä»¶
  CodeBlock,
  Alert,
  Mermaid,
};

export default globalComponents;
```

## é é¢çµ„åˆèˆ‡æœ€çµ‚å‘ˆç¾

### 1. ä¸»è¦é é¢çµ„ä»¶

```typescript
// app/blog/[slug]/page.tsx
import { notFound } from 'next/navigation';
import { getPostBySlug, getPostComponents } from '@/lib/mdx';
import BlogPostContentStatic from '@/components/BlogPostContent.static';
import MDXRenderer from './MDXRenderer';

interface Props {
  params: Promise<{ slug: string }>;
}

export default async function BlogPostPage({ params }: Props) {
  const resolvedParams = await params;
  const post = await getPostBySlug(resolvedParams.slug);

  if (!post) {
    notFound();
  }

  // è¼‰å…¥æ–‡ç« å°ˆç”¨çµ„ä»¶
  const components = await getPostComponents(resolvedParams.slug);

  return (
    <BlogPostContentStatic metadata={post.metadata}>
      <MDXRenderer 
        source={post.content} 
        components={components} 
      />
    </BlogPostContentStatic>
  );
}
```

### 2. é é¢å¸ƒå±€çµ„ä»¶

```typescript
// components/BlogPostContent.static.tsx
import React from 'react';
import Image from 'next/image';
import { getAuthorAvatar } from '@/lib/authors';
import type { BlogMetadata } from '@/lib/types';

interface BlogPostContentProps {
  metadata: BlogMetadata;
  children: React.ReactNode;
}

export default function BlogPostContentStatic({ 
  metadata, 
  children 
}: BlogPostContentProps) {
  return (
    <article className="max-w-4xl mx-auto px-4 py-8">
      <header className="mb-8">
        {/* åˆ†é¡æ¨™ç±¤ */}
        {metadata.category && (
          <div className="mb-4">
            <span className="px-3 py-1 bg-blue-500 text-white text-sm rounded-full">
              {metadata.category}
            </span>
          </div>
        )}

        {/* æ–‡ç« æ¨™é¡Œ */}
        <h1 className="text-4xl md:text-5xl font-bold mb-4 leading-tight">
          {metadata.title}
        </h1>

        {/* å°é¢åœ–ç‰‡ */}
        {metadata.coverImage && (
          <div className="relative w-full h-72 mb-6 rounded-lg overflow-hidden transition-transform duration-300 hover:scale-102">
            <Image
              src={metadata.coverImage}
              alt={metadata.title}
              fill
              className="object-contain bg-white"
              priority
            />
          </div>
        )}

        {/* ä½œè€…èˆ‡æ—¥æœŸè³‡è¨Š */}
        <div className="flex items-center gap-4 text-gray-600 mb-4">
          <div className="flex items-center gap-2">
            <div className="w-8 h-8 relative rounded-full overflow-hidden">
              <Image
                src={getAuthorAvatar(metadata.author)}
                alt={metadata.author}
                fill
                className="object-cover"
              />
            </div>
            <span className="font-medium">{metadata.author}</span>
          </div>
          <span>â€¢</span>
          <time dateTime={metadata.date} className="text-sm">
            {new Date(metadata.date).toLocaleDateString('zh-TW', {
              year: 'numeric',
              month: 'long',
              day: 'numeric'
            })}
          </time>
          {metadata.updatedDate && (
            <>
              <span>â€¢</span>
              <time dateTime={metadata.updatedDate} className="text-sm">
                æ›´æ–°æ–¼ {new Date(metadata.updatedDate).toLocaleDateString('zh-TW')}
              </time>
            </>
          )}
          <span>â€¢</span>
          <span className="text-sm">{metadata.readingTime} åˆ†é˜é–±è®€</span>
        </div>

        {/* æ¨™ç±¤ */}
        {metadata.tags && metadata.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mb-6">
            {metadata.tags.map((tag) => (
              <span
                key={tag}
                className="px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full"
              >
                {tag}
              </span>
            ))}
          </div>
        )}

        {/* ç²¾é¸æ–‡ç« æ¨™ç¤º */}
        {metadata.featured && (
          <div className="mb-4">
            <span className="px-3 py-1 bg-yellow-100 text-yellow-800 text-sm rounded-full">
              â­ ç²¾é¸æ–‡ç« 
            </span>
          </div>
        )}
      </header>

      {/* æ–‡ç« å…§å®¹ */}
      <section className="prose prose-lg max-w-none">
        {children}
      </section>
    </article>
  );
}
```

## å®Œæ•´æ•¸æ“šæµç¤ºä¾‹

### æ­¥é©Ÿ 1: ä½¿ç”¨è€…è¨ªå• `/blog/nextjs-mdx-setup`

### æ­¥é©Ÿ 2: Next.js è·¯ç”±è§£æ
```
URL: /blog/nextjs-mdx-setup
â†“
åŒ¹é…è·¯ç”±: app/blog/[slug]/page.tsx
â†“  
params: { slug: 'nextjs-mdx-setup' }
```

### æ­¥é©Ÿ 3: è®€å–æ–‡ç« è³‡æ–™
```typescript
// åŸ·è¡Œ getPostBySlug('nextjs-mdx-setup')
const post = await getPostBySlug('nextjs-mdx-setup');

// æ­¥é©Ÿ 3.1: è®€å– MDX æª”æ¡ˆ
const fullPath = 'content/posts/nextjs-mdx-setup/content.mdx';
const rawContent = fs.readFileSync(fullPath, 'utf8');

// æ­¥é©Ÿ 3.2: æå– ESM metadata
const { metadata, cleanContent } = await extractMetadataFromMDX(rawContent);
// æå–çµæœï¼š
// metadata = {
//   title: 'Next.js + MDX éƒ¨è½æ ¼å»ºç½®æŒ‡å—',
//   date: '2024-05-21',
//   author: 'Ian Chou',
//   excerpt: 'Complete guide to setting up Next.js with MDX',
//   tags: ['Next.js', 'MDX', 'React'],
//   coverImage: '/images/covers/nextjs-mdx.jpg',
//   readingTime: 8,
//   featured: true
// }
// cleanContent = MDX å…§å®¹ï¼ˆå·²ç§»é™¤ metadata exportï¼‰

// æ­¥é©Ÿ 3.3: é©—è­‰ metadata
const validatedMetadata = validateMetadata(metadata);
```

### æ­¥é©Ÿ 4: è¼‰å…¥æ–‡ç« å°ˆç”¨çµ„ä»¶
```typescript
const components = await getPostComponents('nextjs-mdx-setup');
// å¾ content/posts/nextjs-mdx-setup/components/index.ts å–å¾—ï¼š
// {
//   PerformanceChart: [Function],
//   CodeComparison: [Function],
//   InteractiveDemo: [Function]
// }
```

### æ­¥é©Ÿ 5: æ¸²æŸ“é é¢çµæ§‹
```typescript
return (
  <BlogPostContentStatic metadata={post.metadata}>
    <MDXRenderer 
      source={post.content} 
      components={components} 
    />
  </BlogPostContentStatic>
);
```

### æ­¥é©Ÿ 6: MDX è™•ç†èˆ‡çµ„ä»¶åˆä½µ
```typescript
// MDXRenderer å…§éƒ¨è™•ç†
const mergedComponents = {
  ...globalComponents,  // å…¨åŸŸçµ„ä»¶ (h1, h2, CodeBlock, Alert, ç­‰)
  ...components,        // å€åŸŸçµ„ä»¶ (PerformanceChart, CodeComparison, ç­‰)
};

// MDX åºåˆ—åŒ–ï¼ˆä¸è™•ç† frontmatterï¼Œå› ç‚ºå·²ç¶“åœ¨ä¼ºæœå™¨ç«¯è™•ç†ï¼‰
const serialized = await serialize(source, {
  parseFrontmatter: false
});
```

## é€²éšå„ªåŒ–èˆ‡æœ€ä½³å¯¦è¸

### 1. æ•ˆèƒ½å„ªåŒ–ç­–ç•¥

**ä¸¦è¡Œè™•ç† metadata æå–**
```typescript
export async function getAllPostsMetadata(): Promise<BlogPost[]> {
  const slugs = getAllPostSlugs();
  
  // ä¸¦è¡Œè™•ç†æ‰€æœ‰æ–‡ç« çš„ metadata æå–
  const metadataPromises = slugs.map(async (slug) => {
    try {
      const post = await getPostBySlug(slug);
      return post ? { slug, ...post.metadata } : null;
    } catch (error) {
      console.error(`Error processing ${slug}:`, error);
      return null;
    }
  });

  const results = await Promise.allSettled(metadataPromises);
  
  return results
    .map(result => result.status === 'fulfilled' ? result.value : null)
    .filter((post): post is BlogPost => post !== null)
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}
```

**é–‹ç™¼ç’°å¢ƒå¿«å–æ¸…é™¤**
```typescript
// lib/mdx.ts
if (process.env.NODE_ENV === 'development') {
  // é–‹ç™¼ç’°å¢ƒä¸‹ç›£è½æª”æ¡ˆè®ŠåŒ–ï¼Œæ¸…é™¤å¿«å–
  const chokidar = require('chokidar');
  
  chokidar.watch('content/posts/**/*.mdx').on('change', () => {
    mdxCache.clear();
    console.log('MDX cache cleared due to file change');
  });
}
```

### 2. ESM Metadata é©—è­‰èˆ‡éŒ¯èª¤è™•ç†

**åš´æ ¼çš„ metadata é©—è­‰**
```typescript
// lib/metadata-validator.ts
export function validateBlogMetadata(metadata: any): BlogMetadata {
  const errors: string[] = [];

  // å¿…å¡«æ¬„ä½æª¢æŸ¥
  const requiredFields = ['title', 'date', 'author', 'excerpt'];
  for (const field of requiredFields) {
    if (!metadata[field] || typeof metadata[field] !== 'string') {
      errors.push(`Missing or invalid required field: ${field}`);
    }
  }

  // æ—¥æœŸæ ¼å¼æª¢æŸ¥
  if (metadata.date && isNaN(Date.parse(metadata.date))) {
    errors.push('Invalid date format');
  }

  // tags æ ¼å¼æª¢æŸ¥
  if (metadata.tags && !Array.isArray(metadata.tags)) {
    errors.push('Tags must be an array');
  }

  // readingTime æª¢æŸ¥
  if (metadata.readingTime && (typeof metadata.readingTime !== 'number' || metadata.readingTime <= 0)) {
    errors.push('readingTime must be a positive number');
  }

  // URL æ ¼å¼æª¢æŸ¥
  if (metadata.coverImage && !isValidUrl(metadata.coverImage)) {
    errors.push('Invalid coverImage URL');
  }

  if (metadata.canonicalUrl && !isValidUrl(metadata.canonicalUrl)) {
    errors.push('Invalid canonicalUrl');
  }

  if (errors.length > 0) {
    throw new Error(`Metadata validation failed: ${errors.join(', ')}`);
  }

  return metadata as BlogMetadata;
}

function isValidUrl(urlString: string): boolean {
  try {
    new URL(urlString);
    return true;
  } catch {
    return false;
  }
}
```

### 3. å»ºç½®æ™‚æœŸæª¢æŸ¥

**æ–‡ç« å®Œæ•´æ€§æª¢æŸ¥**
```typescript
// scripts/validate-posts.ts
import { getAllPostSlugs, getPostBySlug } from '@/lib/mdx';

async function validateAllPosts() {
  const slugs = getAllPostSlugs();
  const errors: string[] = [];

  console.log(`ğŸ” Validating ${slugs.length} posts...`);

  for (const slug of slugs) {
    try {
      const post = await getPostBySlug(slug);
      
      if (!post) {
        errors.push(`âŒ ${slug}: Unable to load post`);
        continue;
      }

      // æª¢æŸ¥å¿…è¦æª”æ¡ˆ
      const mdxPath = `content/posts/${slug}/content.mdx`;
      if (!fs.existsSync(mdxPath)) {
        errors.push(`âŒ ${slug}: Missing content.mdx file`);
      }

      // æª¢æŸ¥ metadata å®Œæ•´æ€§
      validateBlogMetadata(post.metadata);

      // æª¢æŸ¥å°é¢åœ–ç‰‡
      if (post.metadata.coverImage) {
        const imagePath = path.join(process.cwd(), 'public', post.metadata.coverImage);
        if (!fs.existsSync(imagePath)) {
          errors.push(`âš ï¸  ${slug}: Cover image not found: ${post.metadata.coverImage}`);
        }
      }

      console.log(`âœ… ${slug}: Valid`);
      
    } catch (error) {
      errors.push(`âŒ ${slug}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  if (errors.length > 0) {
    console.error('\nğŸ“ Validation Errors:');
    errors.forEach(error => console.error(`  ${error}`));
    process.exit(1);
  }

  console.log(`\nğŸ‰ All ${slugs.length} posts validated successfully!`);
}

// å¯ä»¥åœ¨ package.json ä¸­åŠ å…¥: "validate-posts": "tsx scripts/validate-posts.ts"
if (require.main === module) {
  validateAllPosts().catch(console.error);
}
```

### 4. é–‹ç™¼å·¥å…·æ•´åˆ

**VS Code ç¨‹å¼ç¢¼ç‰‡æ®µ**
```json
// .vscode/mdx.code-snippets
{
  "MDX Blog Post Template": {
    "prefix": "mdx-blog",
    "body": [
      "export const metadata = {",
      "  title: '$1',",
      "  date: '$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE',",
      "  author: 'Ian Chou',",
      "  excerpt: '$2',",
      "  tags: [$3],",
      "  coverImage: '/images/posts/$4.webp',",
      "  readingTime: $5,",
      "  featured: false,",
      "  category: '$6'",
      "};",
      "",
      "# $1",
      "",
      "$7"
    ],
    "description": "Create a new MDX blog post with metadata"
  }
}
```

**ESLint è¦å‰‡**
```javascript
// .eslintrc.js
module.exports = {
  // ... å…¶ä»–è¨­å®š
  rules: {
    // ç¢ºä¿ MDX æª”æ¡ˆä¸­çš„ metadata export ç¬¦åˆè¦ç¯„
    'import/no-anonymous-default-export': 'off',
  },
  overrides: [
    {
      files: ['content/posts/**/*.mdx'],
      rules: {
        // MDX ç‰¹å®šè¦å‰‡
        'react/jsx-no-undef': 'off',
      },
    },
  ],
};
```

## çµè«–

åˆ†æ•£å¼ ESM metadata ç®¡ç†ç›¸è¼ƒæ–¼é›†ä¸­å¼ç®¡ç†æä¾›äº†æ›´å¥½çš„é–‹ç™¼é«”é©—å’Œç¶­è­·æ€§ã€‚ä¸»è¦å„ªå‹¢åŒ…æ‹¬ï¼š

### âœ… å„ªå‹¢ç¸½çµ

1. **å…§å®¹å…§èšæ€§**ï¼šmetadata èˆ‡å…§å®¹ä½æ–¼åŒä¸€æª”æ¡ˆï¼Œæ¸›å°‘ç¶­è­·æˆæœ¬
2. **ç‰ˆæœ¬æ§åˆ¶å‹å–„**ï¼šå…§å®¹èˆ‡ metadata çš„ä¿®æ”¹åœ¨åŒä¸€å€‹ commit ä¸­
3. **å‹åˆ¥å®‰å…¨**ï¼šæ¯å€‹æª”æ¡ˆéƒ½æœ‰å®Œæ•´çš„ TypeScript æ”¯æ´
4. **ç¨ç«‹æ€§**ï¼šæ¯ç¯‡æ–‡ç« å¯ä»¥ç¨ç«‹ç®¡ç†ï¼Œäº’ä¸å½±éŸ¿
5. **æ“´å±•æ€§**ï¼šå®¹æ˜“ç‚ºç‰¹å®šæ–‡ç« æ–°å¢å°ˆç”¨çš„ metadata æ¬„ä½

### ğŸ”§ æœ€ä½³å¯¦è¸

1. **ä½¿ç”¨åš´æ ¼çš„ metadata é©—è­‰**ç¢ºä¿è³‡æ–™å“è³ª
2. **å»ºç«‹å®Œæ•´çš„éŒ¯èª¤è™•ç†æ©Ÿåˆ¶**æå‡ç³»çµ±ç©©å®šæ€§
3. **å¯¦ä½œå»ºç½®æ™‚æœŸæª¢æŸ¥**åŠæ—©ç™¼ç¾å•é¡Œ
4. **ä½¿ç”¨é–‹ç™¼å·¥å…·**æå‡å¯«ä½œæ•ˆç‡
5. **è¨­è¨ˆåˆç†çš„å¿«å–ç­–ç•¥**å„ªåŒ–æ•ˆèƒ½

é€™å¥—æ¶æ§‹é©åˆå„ç¨®è¦æ¨¡çš„æŠ€è¡“éƒ¨è½æ ¼ï¼Œå¾å€‹äººéƒ¨è½æ ¼åˆ°åœ˜éšŠçŸ¥è­˜åº«éƒ½èƒ½æœ‰æ•ˆæ‡‰ç”¨ã€‚é€éç†è§£ ESM metadata ç®¡ç†çš„æ ¸å¿ƒæ¦‚å¿µï¼Œé–‹ç™¼è€…å¯ä»¥å»ºç«‹å‡ºæ—¢ç¾ä»£åŒ–åˆæ˜“ç¶­è­·çš„å…§å®¹ç®¡ç†ç³»çµ±ï¼Œç‚ºè®€è€…æä¾›å„ªè³ªçš„é–±è®€é«”é©—ã€‚