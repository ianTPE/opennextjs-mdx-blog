
> **å°ˆæ¡ˆæ¦‚è¿°**ï¼šæ·±åº¦è§£æå¦‚ä½•ä½¿ç”¨ Supabase é–‹æºå¾Œç«¯å¹³å°æ‰“é€ èŒ¶é£²é ç´„ç³»çµ±ï¼Œå¾ PostgreSQL è³‡æ–™åº«è¨­è¨ˆåˆ°å³æ™‚åŠŸèƒ½å¯¦ä½œï¼Œå®Œæ•´çš„ç¾ä»£åŒ–é–‹ç™¼æŒ‡å—ã€‚

## ğŸ¯ ç‚ºä»€éº¼é¸æ“‡ Supabaseï¼Ÿ

åœ¨å®Œæˆ Bubble.io å’Œ Xano çš„èŒ¶èªæ™‚å…‰å¾Œç«¯å¯¦ä½œå¾Œï¼Œæˆ‘å€‘å°‡æ¢ç´¢ç¬¬ä¸‰ç¨®æ–¹æ¡ˆï¼š**Supabase**ã€‚ä½œç‚ºé–‹æºçš„ Firebase æ›¿ä»£å“ï¼ŒSupabase çµåˆäº†å‰å…©è€…çš„å„ªé»ï¼Œä¸¦æä¾›äº†ç¨ç‰¹çš„åƒ¹å€¼ä¸»å¼µï¼š

### Supabase vs Bubble vs Xano æ ¸å¿ƒå·®ç•°

<ThreeWayComparisonTable />

### Supabase çš„æ ¸å¿ƒå„ªå‹¢

**ğŸ”“ é–‹æºé€æ˜**
- å®Œå…¨é–‹æºï¼Œé¿å…å» å•†é–å®š
- å¯è‡ªéƒ¨ç½²ï¼Œå®Œå…¨æŒæ§æ•¸æ“š
- æ´»èºçš„ç¤¾ç¾¤è²¢ç»èˆ‡æ”¯æ´

**âš¡ å³æ™‚èƒ½åŠ›**
- åŸç”Ÿ WebSocket æ”¯æ´
- å³æ™‚è³‡æ–™åº«è¨‚é–±
- å®Œç¾é©åˆè¨‚å–®ç‹€æ…‹å³æ™‚æ›´æ–°

**ğŸ›¡ï¸ ä¼æ¥­ç´šå®‰å…¨**
- Row Level Security (RLS)
- å¤šç¨®èªè­‰æ–¹å¼æ•´åˆ
- ç´°ç²’åº¦æ¬Šé™æ§åˆ¶

**ğŸš€ é–‹ç™¼è€…é«”é©—**
- çœŸæ­£çš„ PostgreSQL
- è‡ªå‹•ç”Ÿæˆ RESTful API
- å¼·å¤§çš„ SQL ç·¨è¼¯å™¨
- TypeScript åŸç”Ÿæ”¯æ´

### å¯¦æˆ°æ¡ˆä¾‹ï¼šç‚ºä»€éº¼ä¼æ¥­é¸æ“‡ Supabase

**æŸå°ç£é›»å•†å¹³å°ä½¿ç”¨ Supabase æˆæœï¼š**
- é–‹ç™¼æ™‚é–“ï¼š1.5 é€±å®Œæˆ MVPï¼Œæ¯” Bubble å¿« 50%
- æˆæœ¬æ•ˆç›Šï¼šå…è²»é¡åº¦æ”¯æ´ 50,000 MAUï¼Œä»˜è²»æ–¹æ¡ˆæ¯” Xano ä¾¿å®œ 40%
- å³æ™‚åŠŸèƒ½ï¼šåŸç”Ÿæ”¯æ´å³æ™‚åº«å­˜æ›´æ–°ï¼ŒBubble/Xano éœ€é¡å¤–é–‹ç™¼
- å¯æ“´å±•æ€§ï¼šè¼•é¬†æ”¯æ´ 100,000+ ç”¨æˆ¶ï¼Œä¸”å¯éš¨æ™‚è‡ªéƒ¨ç½²æ“´å±•
- é–‹æºä¿éšœï¼šé¿å…å¹³å°é—œé–‰é¢¨éšªï¼Œæ°¸ä¹…æŒæ§æ•¸æ“šä¸»æ¬Š

---

## ğŸ—ï¸ Supabase å°ˆæ¡ˆå»ºç½®å®Œæ•´æŒ‡å—

### ç¬¬ä¸€æ­¥ï¼šSupabase å°ˆæ¡ˆåˆå§‹åŒ–

#### 1. å‰µå»ºæ–°å°ˆæ¡ˆ

<SupabaseSetupSteps />

#### 2. å°ˆæ¡ˆé…ç½®

**åŸºæœ¬è¨­å®šï¼š**
```bash
# Supabase å°ˆæ¡ˆè³‡è¨Š
Project Name: chayu-time-booking
Organization: ä½ çš„çµ„ç¹”åç¨±
Database Password: [è‡ªå‹•ç”Ÿæˆå¼·å¯†ç¢¼]
Region: Southeast Asia (Singapore) # å°ç£æœ€è¿‘çš„å€åŸŸ
```

**API è¨­å®šæ“·å–ï¼š**
```javascript
// åœ¨ Supabase Dashboard â†’ Settings â†’ API å–å¾—
const supabaseConfig = {
  url: 'https://your-project-ref.supabase.co',
  anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  serviceRoleKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' // åƒ…å¾Œç«¯ä½¿ç”¨
};
```

#### 3. æœ¬åœ°é–‹ç™¼ç’°å¢ƒè¨­ç½®

**Supabase CLI å®‰è£ï¼š**
```bash
# å®‰è£ Supabase CLI
npm install -g supabase

# åˆå§‹åŒ–æœ¬åœ°å°ˆæ¡ˆ
supabase init

# å•Ÿå‹•æœ¬åœ°é–‹ç™¼ç’°å¢ƒ
supabase start

# é€£çµåˆ°é ç«¯å°ˆæ¡ˆ
supabase link --project-ref your-project-ref
```

**æœ¬åœ°é–‹ç™¼å„ªå‹¢ï¼š**
```json
{
  "local_development": {
    "database": "æœ¬åœ° PostgreSQL å¯¦ä¾‹",
    "api": "æœ¬åœ° API ä¼ºæœå™¨",
    "auth": "æœ¬åœ°èªè­‰æœå‹™",
    "storage": "æœ¬åœ°æª”æ¡ˆå„²å­˜",
    "edge_functions": "æœ¬åœ° Deno runtime"
  },
  "benefits": [
    "é›¢ç·šé–‹ç™¼èƒ½åŠ›",
    "å¿«é€Ÿè¿­ä»£æ¸¬è©¦",
    "æ•¸æ“šé·ç§»é©—è­‰",
    "å®Œæ•´çš„é–‹ç™¼ç’°å¢ƒéš”é›¢"
  ]
}
```

---

## ğŸ—„ï¸ ç¬¬äºŒæ­¥ï¼šPostgreSQL è³‡æ–™åº«è¨­è¨ˆ

### 1. Users ç”¨æˆ¶è¡¨ ğŸ‘¤

**SQL Schema å»ºç«‹ï¼š**
```sql
-- åœ¨ Supabase SQL Editor ä¸­åŸ·è¡Œ
CREATE TABLE users (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  line_user_id TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  picture_url TEXT,
  phone_number TEXT,
  email TEXT,
  membership_level TEXT DEFAULT 'bronze' CHECK (membership_level IN ('bronze', 'silver', 'gold')),
  points_balance INTEGER DEFAULT 0 CHECK (points_balance >= 0),
  wallet_balance DECIMAL(10,2) DEFAULT 0.00 CHECK (wallet_balance >= 0),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  last_login TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW())
);

-- å»ºç«‹ç´¢å¼•å„ªåŒ–æŸ¥è©¢æ•ˆèƒ½
CREATE INDEX idx_users_line_user_id ON users(line_user_id);
CREATE INDEX idx_users_membership_level ON users(membership_level);
CREATE INDEX idx_users_created_at ON users(created_at);

-- å»ºç«‹æ›´æ–°æ™‚é–“è§¸ç™¼å™¨
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc'::TEXT, NOW());
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE
    ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- RLS (Row Level Security) æ”¿ç­–
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- ç”¨æˆ¶åªèƒ½è®€å–å’Œæ›´æ–°è‡ªå·±çš„è³‡æ–™
CREATE POLICY "Users can view own data" ON users
    FOR SELECT USING (auth.jwt() ->> 'line_user_id' = line_user_id);

CREATE POLICY "Users can update own data" ON users
    FOR UPDATE USING (auth.jwt() ->> 'line_user_id' = line_user_id);

-- å…è¨±è¨»å†Šæ–°ç”¨æˆ¶
CREATE POLICY "Enable insert for authenticated users" ON users
    FOR INSERT WITH CHECK (true);
```

**TypeScript é¡å‹å®šç¾©ï¼š**
```typescript
// types/database.ts
export interface User {
  id: string;
  line_user_id: string;
  display_name: string;
  picture_url?: string;
  phone_number?: string;
  email?: string;
  membership_level: 'bronze' | 'silver' | 'gold';
  points_balance: number;
  wallet_balance: number;
  created_at: string;
  updated_at: string;
  last_login: string;
}
```

### 2. Products å•†å“è¡¨ ğŸµ

**å®Œæ•´å•†å“è³‡æ–™è¡¨ï¼š**
```sql
CREATE TABLE products (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  price DECIMAL(10,2) NOT NULL CHECK (price > 0),
  category TEXT NOT NULL,
  description TEXT,
  image_url TEXT,
  rating DECIMAL(3,2) CHECK (rating >= 0 AND rating <= 5),
  review_count INTEGER DEFAULT 0 CHECK (review_count >= 0),
  preparation_time INTEGER DEFAULT 15 CHECK (preparation_time > 0),
  stock_quantity INTEGER DEFAULT 100 CHECK (stock_quantity >= 0),
  low_stock_threshold INTEGER DEFAULT 10 CHECK (low_stock_threshold >= 0),
  availability_status BOOLEAN DEFAULT true,
  tags TEXT[] DEFAULT '{}',
  nutrition_info JSONB DEFAULT '{}',
  customization_options JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL
);

-- æ•ˆèƒ½å„ªåŒ–ç´¢å¼•
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_products_availability ON products(availability_status);
CREATE INDEX idx_products_rating ON products(rating DESC);
CREATE INDEX idx_products_tags ON products USING GIN(tags);
CREATE INDEX idx_products_price ON products(price);

-- å…¨æ–‡æœå°‹ç´¢å¼•
CREATE INDEX idx_products_search ON products 
USING GIN(to_tsvector('english', name || ' ' || COALESCE(description, '')));

-- æ›´æ–°æ™‚é–“è§¸ç™¼å™¨
CREATE TRIGGER update_products_updated_at BEFORE UPDATE
    ON products FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- RLS æ”¿ç­– - ç”¢å“å°æ‰€æœ‰äººå¯è¦‹
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Products are viewable by everyone" ON products FOR SELECT USING (true);
CREATE POLICY "Only admins can modify products" ON products 
    FOR ALL USING (auth.jwt() ->> 'role' = 'admin');
```

**å•†å“å®¢è£½åŒ–é¸é …ç¯„ä¾‹ï¼š**
```json
{
  "sweetness": {
    "type": "select",
    "options": ["ç„¡ç³–", "å¾®ç³–", "åŠç³–", "å°‘ç³–", "æ­£å¸¸ç³–"],
    "default": "åŠç³–"
  },
  "ice_level": {
    "type": "select", 
    "options": ["å»å†°", "å¾®å†°", "å°‘å†°", "æ­£å¸¸å†°"],
    "default": "å°‘å†°"
  },
  "toppings": {
    "type": "multi_select",
    "options": [
      {"name": "çç ", "price": 10},
      {"name": "æ¤°æœ", "price": 8},
      {"name": "å¸ƒä¸", "price": 15},
      {"name": "ç´…è±†", "price": 12}
    ],
    "max_selections": 3
  },
  "size": {
    "type": "select",
    "options": [
      {"name": "ä¸­æ¯", "price_modifier": 0},
      {"name": "å¤§æ¯", "price_modifier": 10}
    ],
    "default": "ä¸­æ¯"
  }
}
```

### 3. Stores é–€å¸‚è¡¨ ğŸª

**é€²éšé–€å¸‚ç®¡ç†ï¼š**
```sql
CREATE TABLE stores (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  address TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  operating_hours JSONB NOT NULL,
  special_hours JSONB DEFAULT '{}', -- ç‰¹æ®Šç‡Ÿæ¥­æ™‚é–“ï¼ˆç¯€æ—¥ç­‰ï¼‰
  current_queue_count INTEGER DEFAULT 0 CHECK (current_queue_count >= 0),
  average_wait_time INTEGER DEFAULT 10 CHECK (average_wait_time >= 0),
  max_concurrent_orders INTEGER DEFAULT 50 CHECK (max_concurrent_orders > 0),
  latitude DECIMAL(10,8),
  longitude DECIMAL(11,8),
  store_status TEXT DEFAULT 'open' CHECK (store_status IN ('open', 'busy', 'closed', 'maintenance')),
  facilities TEXT[] DEFAULT '{}', -- è¨­æ–½: WiFi, åœè»Šå ´, å¤–é€ç­‰
  payment_methods TEXT[] DEFAULT '{"cash", "card", "linepay", "wallet"}',
  manager_id UUID REFERENCES users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL
);

-- åœ°ç†ä½ç½®æœå°‹å„ªåŒ–
CREATE INDEX idx_stores_location ON stores USING GIST(ll_to_earth(latitude, longitude));
CREATE INDEX idx_stores_status ON stores(store_status);
CREATE INDEX idx_stores_facilities ON stores USING GIN(facilities);

-- åœ°ç†ä½ç½®æŸ¥è©¢å‡½æ•¸
CREATE OR REPLACE FUNCTION nearby_stores(
  user_lat DECIMAL,
  user_lng DECIMAL,
  radius_km DECIMAL DEFAULT 5
)
RETURNS TABLE(
  store_id UUID,
  name TEXT,
  distance_km DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.name,
    ROUND(earth_distance(ll_to_earth(user_lat, user_lng), ll_to_earth(s.latitude, s.longitude)) / 1000, 2) as distance_km
  FROM stores s
  WHERE s.store_status = 'open'
    AND earth_distance(ll_to_earth(user_lat, user_lng), ll_to_earth(s.latitude, s.longitude)) <= radius_km * 1000
  ORDER BY distance_km;
END;
$$ LANGUAGE plpgsql;

-- RLS æ”¿ç­–
ALTER TABLE stores ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Stores are viewable by everyone" ON stores FOR SELECT USING (true);
```

### 4. Orders è¨‚å–®è¡¨ ğŸ“‹

**å®Œæ•´è¨‚å–®ç³»çµ±ï¼š**
```sql
CREATE TABLE orders (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  order_number TEXT UNIQUE NOT NULL, -- äººé¡å¯è®€çš„è¨‚å–®ç·¨è™Ÿ
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE RESTRICT,
  order_items JSONB NOT NULL,
  total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount > 0),
  discount_amount DECIMAL(10,2) DEFAULT 0 CHECK (discount_amount >= 0),
  final_amount DECIMAL(10,2) GENERATED ALWAYS AS (total_amount - discount_amount) STORED,
  payment_method TEXT NOT NULL CHECK (payment_method IN ('wallet', 'points', 'linepay', 'credit', 'cash')),
  payment_status TEXT DEFAULT 'pending' CHECK (payment_status IN ('pending', 'paid', 'failed', 'refunded')),
  order_status TEXT DEFAULT 'pending' CHECK (order_status IN ('pending', 'confirmed', 'preparing', 'ready', 'completed', 'cancelled')),
  order_type TEXT NOT NULL CHECK (order_type IN ('pickup_now', 'pickup_scheduled', 'delivery')),
  scheduled_time TIMESTAMP WITH TIME ZONE,
  estimated_pickup_time TIMESTAMP WITH TIME ZONE,
  actual_pickup_time TIMESTAMP WITH TIME ZONE,
  special_instructions TEXT,
  loyalty_points_used INTEGER DEFAULT 0,
  loyalty_points_earned INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL
);

-- è¨‚å–®ç·¨è™Ÿç”Ÿæˆå‡½æ•¸
CREATE OR REPLACE FUNCTION generate_order_number()
RETURNS TEXT AS $$
DECLARE
  new_number TEXT;
  counter INTEGER;
BEGIN
  -- æ ¼å¼: CY20250615001 (CY + æ—¥æœŸ + æµæ°´è™Ÿ)
  SELECT COALESCE(MAX(CAST(RIGHT(order_number, 3) AS INTEGER)), 0) + 1
  INTO counter
  FROM orders 
  WHERE order_number LIKE 'CY' || TO_CHAR(NOW(), 'YYYYMMDD') || '%';
  
  new_number := 'CY' || TO_CHAR(NOW(), 'YYYYMMDD') || LPAD(counter::TEXT, 3, '0');
  RETURN new_number;
END;
$$ LANGUAGE plpgsql;

-- è‡ªå‹•ç”Ÿæˆè¨‚å–®ç·¨è™Ÿè§¸ç™¼å™¨
CREATE OR REPLACE FUNCTION set_order_number()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.order_number IS NULL THEN
    NEW.order_number := generate_order_number();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_order_number
  BEFORE INSERT ON orders
  FOR EACH ROW EXECUTE FUNCTION set_order_number();

-- æ•ˆèƒ½ç´¢å¼•
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_store_id ON orders(store_id);
CREATE INDEX idx_orders_status ON orders(order_status);
CREATE INDEX idx_orders_created_at ON orders(created_at);
CREATE INDEX idx_orders_order_number ON orders(order_number);

-- RLS æ”¿ç­–
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own orders" ON orders FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Users can insert own orders" ON orders FOR INSERT WITH CHECK (user_id = auth.uid());
```

### 5. Order Status History è¨‚å–®ç‹€æ…‹æ­·å² ğŸ“Š

**å®Œæ•´ç‹€æ…‹è¿½è¹¤ï¼š**
```sql
CREATE TABLE order_status_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
  previous_status TEXT,
  new_status TEXT NOT NULL,
  changed_by UUID REFERENCES users(id),
  change_reason TEXT,
  notes TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::TEXT, NOW()) NOT NULL
);

-- è‡ªå‹•è¨˜éŒ„ç‹€æ…‹è®Šæ›´
CREATE OR REPLACE FUNCTION log_order_status_change()
RETURNS TRIGGER AS $$
BEGIN
  -- åªåœ¨ç‹€æ…‹çœŸæ­£è®Šæ›´æ™‚è¨˜éŒ„
  IF OLD.order_status IS DISTINCT FROM NEW.order_status THEN
    INSERT INTO order_status_history (
      order_id,
      previous_status,
      new_status,
      changed_by,
      change_reason,
      metadata
    ) VALUES (
      NEW.id,
      OLD.order_status,
      NEW.order_status,
      auth.uid(),
      CASE 
        WHEN NEW.order_status = 'confirmed' THEN 'Order confirmed by system'
        WHEN NEW.order_status = 'preparing' THEN 'Order started preparation'
        WHEN NEW.order_status = 'ready' THEN 'Order ready for pickup'
        WHEN NEW.order_status = 'completed' THEN 'Order completed'
        WHEN NEW.order_status = 'cancelled' THEN 'Order cancelled'
        ELSE 'Status updated'
      END,
      jsonb_build_object(
        'timestamp', NOW(),
        'previous_total', OLD.total_amount,
        'new_total', NEW.total_amount
      )
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_log_order_status_change
  AFTER UPDATE ON orders
  FOR EACH ROW EXECUTE FUNCTION log_order_status_change();
```

---

## âš™ï¸ ç¬¬ä¸‰æ­¥ï¼šSupabase API æ•´åˆ

### 1. JavaScript Client è¨­å®š

**å‰ç«¯ Client åˆå§‹åŒ–ï¼š**
```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  },
  realtime: {
    params: {
      eventsPerSecond: 10
    }
  }
});

// TypeScript é¡å‹æ”¯æ´
export type Database = {
  public: {
    Tables: {
      users: {
        Row: User;
        Insert: Omit<User, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<User, 'id' | 'created_at'>>;
      };
      products: {
        Row: Product;
        Insert: Omit<Product, 'id' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Product, 'id' | 'created_at'>>;
      };
      orders: {
        Row: Order;
        Insert: Omit<Order, 'id' | 'order_number' | 'created_at' | 'updated_at'>;
        Update: Partial<Omit<Order, 'id' | 'order_number' | 'created_at'>>;
      };
    };
  };
};
```

### 2. ç”¨æˆ¶ç®¡ç†åŠŸèƒ½ ğŸ‘¤

**LINE LIFF æ•´åˆè¨»å†Šï¼š**
```typescript
// services/userService.ts
import { supabase } from '@/lib/supabase';

export class UserService {
  // ç”¨æˆ¶è¨»å†Š/ç™»å…¥
  static async registerOrLoginUser(liffProfile: any) {
    try {
      // æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²å­˜åœ¨
      const { data: existingUser, error: fetchError } = await supabase
        .from('users')
        .select('*')
        .eq('line_user_id', liffProfile.userId)
        .single();

      if (fetchError && fetchError.code !== 'PGRST116') {
        throw fetchError;
      }

      if (existingUser) {
        // æ›´æ–°æœ€å¾Œç™»å…¥æ™‚é–“
        const { data: updatedUser, error: updateError } = await supabase
          .from('users')
          .update({ 
            last_login: new Date().toISOString(),
            display_name: liffProfile.displayName,
            picture_url: liffProfile.pictureUrl 
          })
          .eq('id', existingUser.id)
          .select()
          .single();

        if (updateError) throw updateError;
        return { user: updatedUser, action: 'login' };
      } else {
        // å‰µå»ºæ–°ç”¨æˆ¶
        const { data: newUser, error: insertError } = await supabase
          .from('users')
          .insert({
            line_user_id: liffProfile.userId,
            display_name: liffProfile.displayName,
            picture_url: liffProfile.pictureUrl,
            membership_level: 'bronze',
            points_balance: 0,
            wallet_balance: 0
          })
          .select()
          .single();

        if (insertError) throw insertError;
        return { user: newUser, action: 'register' };
      }
    } catch (error) {
      console.error('ç”¨æˆ¶è¨»å†Š/ç™»å…¥éŒ¯èª¤:', error);
      throw error;
    }
  }

  // å–å¾—ç”¨æˆ¶è³‡æ–™
  static async getUserData(lineUserId: string) {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('line_user_id', lineUserId)
      .single();

    if (error) throw error;
    return data;
  }

  // æ›´æ–°ç”¨æˆ¶é»æ•¸
  static async updateUserPoints(userId: string, pointsChange: number) {
    const { data, error } = await supabase
      .rpc('update_user_points', {
        user_id: userId,
        points_change: pointsChange
      });

    if (error) throw error;
    return data;
  }
}
```

**PostgreSQL é»æ•¸æ›´æ–°å‡½æ•¸ï¼š**
```sql
-- å»ºç«‹å®‰å…¨çš„é»æ•¸æ›´æ–°å‡½æ•¸
CREATE OR REPLACE FUNCTION update_user_points(
  user_id UUID,
  points_change INTEGER
)
RETURNS users AS $$
DECLARE
  updated_user users%ROWTYPE;
BEGIN
  UPDATE users 
  SET 
    points_balance = GREATEST(0, points_balance + points_change),
    updated_at = NOW()
  WHERE id = user_id
  RETURNING * INTO updated_user;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found with id: %', user_id;
  END IF;
  
  RETURN updated_user;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3. å•†å“ç®¡ç†åŠŸèƒ½ ğŸµ

**é€²éšå•†å“æŸ¥è©¢ï¼š**
```typescript
// services/productService.ts
export class ProductService {
  // å–å¾—å•†å“åˆ—è¡¨ï¼ˆæ”¯æ´åˆ†é¡ã€æœå°‹ã€æ’åºï¼‰
  static async getProducts(options: {
    category?: string;
    search?: string;
    sortBy?: 'name' | 'price' | 'rating';
    sortOrder?: 'asc' | 'desc';
    limit?: number;
    offset?: number;
  } = {}) {
    let query = supabase
      .from('products')
      .select('*')
      .eq('availability_status', true)
      .gt('stock_quantity', 0);

    // åˆ†é¡ç¯©é¸
    if (options.category && options.category !== 'all') {
      query = query.eq('category', options.category);
    }

    // æœå°‹åŠŸèƒ½
    if (options.search) {
      query = query.textSearch('name,description', options.search);
    }

    // æ’åº
    if (options.sortBy) {
      query = query.order(options.sortBy, { 
        ascending: options.sortOrder === 'asc' 
      });
    } else {
      query = query.order('rating', { ascending: false })
                   .order('name', { ascending: true });
    }

    // åˆ†é 
    if (options.limit) {
      query = query.limit(options.limit);
    }
    if (options.offset) {
      query = query.range(options.offset, options.offset + (options.limit || 50) - 1);
    }

    const { data, error, count } = await query;
    
    if (error) throw error;
    
    return { 
      products: data,
      totalCount: count,
      hasMore: options.offset ? (options.offset + data.length) < (count || 0) : false
    };
  }

  // å–å¾—å•†å“åˆ†é¡èˆ‡çµ±è¨ˆ
  static async getProductCategories() {
    const { data, error } = await supabase
      .rpc('get_product_categories_stats');

    if (error) throw error;
    return data;
  }

  // å³æ™‚åº«å­˜è¨‚é–±
  static subscribeToStockUpdates(productIds: string[], callback: (payload: any) => void) {
    return supabase
      .channel('stock-updates')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'products',
          filter: `id=in.(${productIds.join(',')})`
        },
        callback
      )
      .subscribe();
  }
}
```

**å•†å“åˆ†é¡çµ±è¨ˆå‡½æ•¸ï¼š**
```sql
-- å»ºç«‹å•†å“åˆ†é¡çµ±è¨ˆå‡½æ•¸
CREATE OR REPLACE FUNCTION get_product_categories_stats()
RETURNS TABLE(
  category TEXT,
  product_count BIGINT,
  avg_rating NUMERIC,
  min_price NUMERIC,
  max_price NUMERIC,
  total_stock INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    p.category,
    COUNT(*) as product_count,
    ROUND(AVG(p.rating), 2) as avg_rating,
    MIN(p.price) as min_price,
    MAX(p.price) as max_price,
    SUM(p.stock_quantity)::INTEGER as total_stock
  FROM products p
  WHERE p.availability_status = true
  GROUP BY p.category
  ORDER BY p.category;
END;
$$ LANGUAGE plpgsql;
```

### 4. å³æ™‚è¨‚å–®ç®¡ç† ğŸ“‹

**å®Œæ•´è¨‚å–®è™•ç†æµç¨‹ï¼š**
```typescript
// services/orderService.ts
export class OrderService {
  // å‰µå»ºè¨‚å–®
  static async createOrder(orderData: {
    userId: string;
    storeId: string;
    items: OrderItem[];
    paymentMethod: string;
    orderType: string;
    scheduledTime?: string;
    specialInstructions?: string;
  }) {
    try {
      // é–‹å§‹äº¤æ˜“
      const { data, error } = await supabase.rpc('create_order_transaction', {
        p_user_id: orderData.userId,
        p_store_id: orderData.storeId,
        p_order_items: JSON.stringify(orderData.items),
        p_payment_method: orderData.paymentMethod,
        p_order_type: orderData.orderType,
        p_scheduled_time: orderData.scheduledTime,
        p_special_instructions: orderData.specialInstructions
      });

      if (error) throw error;

      // ç™¼é€å³æ™‚é€šçŸ¥
      await this.notifyOrderCreated(data.order_id);

      return data;
    } catch (error) {
      console.error('è¨‚å–®å‰µå»ºå¤±æ•—:', error);
      throw error;
    }
  }

  // è¨‚å–®ç‹€æ…‹å³æ™‚è¨‚é–±
  static subscribeToOrderUpdates(userId: string, callback: (payload: any) => void) {
    return supabase
      .channel(`user-orders-${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `user_id=eq.${userId}`
        },
        callback
      )
      .subscribe();
  }

  // å–å¾—ç”¨æˆ¶è¨‚å–®æ­·å²
  static async getUserOrders(userId: string, options: {
    status?: string;
    limit?: number;
    offset?: number;
  } = {}) {
    let query = supabase
      .from('orders')
      .select(`
        *,
        stores:store_id (name, address, phone),
        order_status_history (
          previous_status,
          new_status,
          change_reason,
          created_at
        )
      `)
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (options.status) {
      query = query.eq('order_status', options.status);
    }

    if (options.limit) {
      query = query.limit(options.limit);
    }

    if (options.offset) {
      query = query.range(options.offset, options.offset + (options.limit || 20) - 1);
    }

    const { data, error } = await query;
    if (error) throw error;

    return data.map(order => ({
      ...order,
      items: JSON.parse(order.order_items as string),
      statusHistory: order.order_status_history
    }));
  }

  // å³æ™‚é€šçŸ¥
  private static async notifyOrderCreated(orderId: string) {
    // ç™¼é€åˆ°åº—å®¶ç®¡ç†ç³»çµ±
    const { error } = await supabase
      .channel('store-notifications')
      .send({
        type: 'broadcast',
        event: 'new-order',
        payload: { orderId, timestamp: new Date().toISOString() }
      });

    if (error) console.error('é€šçŸ¥ç™¼é€å¤±æ•—:', error);
  }
}
```

**è¤‡é›œè¨‚å–®äº¤æ˜“å‡½æ•¸ï¼š**
```sql
-- å»ºç«‹å®Œæ•´çš„è¨‚å–®å‰µå»ºäº¤æ˜“
CREATE OR REPLACE FUNCTION create_order_transaction(
  p_user_id UUID,
  p_store_id UUID,
  p_order_items JSONB,
  p_payment_method TEXT,
  p_order_type TEXT,
  p_scheduled_time TIMESTAMP WITH TIME ZONE DEFAULT NULL,
  p_special_instructions TEXT DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
  v_order_id UUID;
  v_total_amount DECIMAL(10,2) := 0;
  v_user_record users%ROWTYPE;
  v_store_record stores%ROWTYPE;
  v_item JSONB;
  v_product_record products%ROWTYPE;
  v_points_earned INTEGER := 0;
  v_estimated_pickup TIMESTAMP WITH TIME ZONE;
BEGIN
  -- é©—è­‰ç”¨æˆ¶
  SELECT * INTO v_user_record FROM users WHERE id = p_user_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'User not found';
  END IF;

  -- é©—è­‰é–€å¸‚
  SELECT * INTO v_store_record FROM stores WHERE id = p_store_id AND store_status = 'open';
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Store not available';
  END IF;

  -- è¨ˆç®—ç¸½é‡‘é¡ä¸¦é©—è­‰å•†å“
  FOR v_item IN SELECT * FROM jsonb_array_elements(p_order_items)
  LOOP
    SELECT * INTO v_product_record 
    FROM products 
    WHERE id = (v_item->>'product_id')::UUID 
      AND availability_status = true;
    
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Product % not available', v_item->>'name';
    END IF;
    
    -- æª¢æŸ¥åº«å­˜
    IF v_product_record.stock_quantity < (v_item->>'quantity')::INTEGER THEN
      RAISE EXCEPTION 'Insufficient stock for %', v_item->>'name';
    END IF;
    
    -- ç´¯è¨ˆç¸½é‡‘é¡
    v_total_amount := v_total_amount + (v_item->>'subtotal')::DECIMAL(10,2);
    
    -- æ›´æ–°åº«å­˜
    UPDATE products 
    SET stock_quantity = stock_quantity - (v_item->>'quantity')::INTEGER
    WHERE id = v_product_record.id;
  END LOOP;

  -- è™•ç†ä»˜æ¬¾
  IF p_payment_method = 'wallet' THEN
    IF v_user_record.wallet_balance < v_total_amount THEN
      RAISE EXCEPTION 'Insufficient wallet balance';
    END IF;
    
    UPDATE users 
    SET wallet_balance = wallet_balance - v_total_amount
    WHERE id = p_user_id;
    
  ELSIF p_payment_method = 'points' THEN
    IF v_user_record.points_balance < v_total_amount THEN
      RAISE EXCEPTION 'Insufficient points balance';
    END IF;
    
    UPDATE users 
    SET points_balance = points_balance - v_total_amount::INTEGER
    WHERE id = p_user_id;
  END IF;

  -- è¨ˆç®—é ä¼°å–é¤æ™‚é–“
  IF p_order_type = 'pickup_now' THEN
    v_estimated_pickup := NOW() + INTERVAL '1 minute' * (v_store_record.current_queue_count * 5 + 10);
  ELSE
    v_estimated_pickup := p_scheduled_time;
  END IF;

  -- å‰µå»ºè¨‚å–®
  INSERT INTO orders (
    user_id,
    store_id,
    order_items,
    total_amount,
    payment_method,
    order_type,
    scheduled_time,
    estimated_pickup_time,
    special_instructions
  ) VALUES (
    p_user_id,
    p_store_id,
    p_order_items,
    v_total_amount,
    p_payment_method,
    p_order_type,
    p_scheduled_time,
    v_estimated_pickup,
    p_special_instructions
  ) RETURNING id INTO v_order_id;

  -- æ›´æ–°é–€å¸‚æ’éšŠç‹€æ³
  IF p_order_type = 'pickup_now' THEN
    UPDATE stores 
    SET current_queue_count = current_queue_count + 1
    WHERE id = p_store_id;
  END IF;

  -- è¨ˆç®—ä¸¦çµ¦äºˆé»æ•¸å›é¥‹
  v_points_earned := CASE v_user_record.membership_level
    WHEN 'bronze' THEN (v_total_amount * 0.01)::INTEGER
    WHEN 'silver' THEN (v_total_amount * 0.015)::INTEGER
    WHEN 'gold' THEN (v_total_amount * 0.02)::INTEGER
    ELSE 0
  END;

  UPDATE users 
  SET points_balance = points_balance + v_points_earned
  WHERE id = p_user_id;

  -- è¿”å›çµæœ
  RETURN jsonb_build_object(
    'success', true,
    'order_id', v_order_id,
    'total_amount', v_total_amount,
    'points_earned', v_points_earned,
    'estimated_pickup_time', v_estimated_pickup
  );

EXCEPTION WHEN OTHERS THEN
  -- å›æ»¾æ‰€æœ‰è®Šæ›´
  RAISE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## ğŸ”— ç¬¬å››æ­¥ï¼šå³æ™‚åŠŸèƒ½å¯¦ä½œ

### 1. å³æ™‚è¨‚å–®ç‹€æ…‹æ›´æ–°

**å‰ç«¯å³æ™‚è¨‚é–±ï¼š**
```typescript
// hooks/useRealtimeOrders.ts
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';

export function useRealtimeOrders(userId: string) {
  const [orders, setOrders] = useState<Order[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // åˆå§‹è¼‰å…¥è¨‚å–®
    loadOrders();

    // è¨­å®šå³æ™‚è¨‚é–±
    const channel = supabase
      .channel(`orders-${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `user_id=eq.${userId}`
        },
        (payload) => {
          handleOrderUpdate(payload);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId]);

  const loadOrders = async () => {
    try {
      const data = await OrderService.getUserOrders(userId, { limit: 20 });
      setOrders(data);
    } catch (error) {
      console.error('è¼‰å…¥è¨‚å–®å¤±æ•—:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleOrderUpdate = (payload: any) => {
    const { eventType, new: newOrder, old: oldOrder } = payload;

    setOrders(prevOrders => {
      switch (eventType) {
        case 'INSERT':
          return [newOrder, ...prevOrders];
        
        case 'UPDATE':
          return prevOrders.map(order => 
            order.id === newOrder.id ? { ...order, ...newOrder } : order
          );
        
        case 'DELETE':
          return prevOrders.filter(order => order.id !== oldOrder.id);
        
        default:
          return prevOrders;
      }
    });

    // é¡¯ç¤ºç‹€æ…‹è®Šæ›´é€šçŸ¥
    if (eventType === 'UPDATE' && oldOrder.order_status !== newOrder.order_status) {
      showOrderStatusNotification(newOrder);
    }
  };

  const showOrderStatusNotification = (order: Order) => {
    const statusMessages = {
      confirmed: 'è¨‚å–®å·²ç¢ºèªï¼',
      preparing: 'é–‹å§‹è£½ä½œä¸­...',
      ready: 'é¤é»å·²æº–å‚™å®Œæˆï¼Œè«‹å‰å¾€å–é¤',
      completed: 'æ„Ÿè¬æ‚¨çš„è¨‚è³¼ï¼',
      cancelled: 'è¨‚å–®å·²å–æ¶ˆ'
    };

    // é¡¯ç¤º toast é€šçŸ¥æˆ–æ¨æ’­
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification('èŒ¶èªæ™‚å…‰', {
        body: `è¨‚å–® ${order.order_number}: ${statusMessages[order.order_status]}`,
        icon: '/icons/tea-icon.png'
      });
    }
  };

  return { orders, loading, refetch: loadOrders };
}
```

### 2. å³æ™‚åº«å­˜æ›´æ–°

**å•†å“åº«å­˜å³æ™‚ç›£æ§ï¼š**
```typescript
// hooks/useRealtimeInventory.ts
export function useRealtimeInventory(productIds: string[]) {
  const [inventory, setInventory] = useState<Record<string, number>>({});

  useEffect(() => {
    const channel = supabase
      .channel('inventory-updates')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'products',
          filter: `id=in.(${productIds.join(',')})`
        },
        (payload) => {
          const { new: updatedProduct } = payload;
          setInventory(prev => ({
            ...prev,
            [updatedProduct.id]: updatedProduct.stock_quantity
          }));

          // ä½åº«å­˜è­¦ç¤º
          if (updatedProduct.stock_quantity <= updatedProduct.low_stock_threshold) {
            showLowStockAlert(updatedProduct);
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [productIds]);

  return inventory;
}
```

### 3. å³æ™‚é–€å¸‚æ’éšŠç‹€æ³

**é–€å¸‚æ’éšŠå³æ™‚æ›´æ–°ï¼š**
```typescript
// hooks/useRealtimeQueue.ts
export function useRealtimeQueue(storeId: string) {
  const [queueData, setQueueData] = useState({
    currentCount: 0,
    averageWait: 0,
    estimatedWait: 0
  });

  useEffect(() => {
    const channel = supabase
      .channel(`queue-${storeId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'stores',
          filter: `id=eq.${storeId}`
        },
        (payload) => {
          const { new: updatedStore } = payload;
          setQueueData({
            currentCount: updatedStore.current_queue_count,
            averageWait: updatedStore.average_wait_time,
            estimatedWait: updatedStore.current_queue_count * 5
          });
        }
      )
      .subscribe();

    // åˆå§‹è¼‰å…¥
    loadInitialQueueData();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [storeId]);

  const loadInitialQueueData = async () => {
    const { data } = await supabase
      .from('stores')
      .select('current_queue_count, average_wait_time')
      .eq('id', storeId)
      .single();

    if (data) {
      setQueueData({
        currentCount: data.current_queue_count,
        averageWait: data.average_wait_time,
        estimatedWait: data.current_queue_count * 5
      });
    }
  };

  return queueData;
}
```

---

## ğŸ›¡ï¸ ç¬¬äº”æ­¥ï¼šå®‰å…¨æ€§èˆ‡æ¬Šé™æ§åˆ¶

### 1. Row Level Security (RLS) é€²éšè¨­å®š

**ç´°ç²’åº¦æ¬Šé™æ§åˆ¶ï¼š**
```sql
-- ç”¨æˆ¶è¡¨ RLS æ”¿ç­–å¢å¼·
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id OR auth.jwt() ->> 'line_user_id' = line_user_id);

CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);

-- ç®¡ç†å“¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰ç”¨æˆ¶
CREATE POLICY "Admins can view all users" ON users
  FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

-- è¨‚å–®è¡¨ RLS æ”¿ç­–
CREATE POLICY "Users can view own orders" ON orders
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can create orders" ON orders
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- åº—å“¡å¯ä»¥æŸ¥çœ‹å’Œæ›´æ–°åº—å…§è¨‚å–®
CREATE POLICY "Store staff can manage store orders" ON orders
  FOR ALL USING (
    store_id IN (
      SELECT id FROM stores 
      WHERE manager_id = auth.uid() 
      OR auth.jwt() ->> 'role' = 'store_staff'
    )
  );

-- å•†å“è¡¨ RLS - åˆ†å±¤æ¬Šé™
CREATE POLICY "Everyone can view available products" ON products
  FOR SELECT USING (availability_status = true);

CREATE POLICY "Store managers can update own store products" ON products
  FOR UPDATE USING (
    auth.jwt() ->> 'role' IN ('admin', 'store_manager')
  );
```

### 2. è‡ªå®šç¾©èªè­‰ Hook

**JWT Token è™•ç†ï¼š**
```typescript
// hooks/useAuth.ts
import { useEffect, useState } from 'react';
import { supabase } from '@/lib/supabase';

export function useAuth() {
  const [user, setUser] = useState(null);
  const [session, setSession] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // å–å¾—ç›®å‰ session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // ç›£è½èªè­‰ç‹€æ…‹è®Šæ›´
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        setLoading(false);

        // åŒæ­¥ç”¨æˆ¶è³‡æ–™
        if (session?.user && event === 'SIGNED_IN') {
          await syncUserData(session.user);
        }
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  const signInWithLineToken = async (lineToken: string, userProfile: any) => {
    try {
      // ä½¿ç”¨è‡ªå®šç¾©èªè­‰å‡½æ•¸
      const { data, error } = await supabase.auth.signInWithIdToken({
        provider: 'custom',
        token: lineToken,
        options: {
          userData: userProfile
        }
      });

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('LINE èªè­‰å¤±æ•—:', error);
      throw error;
    }
  };

  const syncUserData = async (authUser: any) => {
    try {
      const { error } = await supabase
        .from('users')
        .upsert({
          id: authUser.id,
          line_user_id: authUser.user_metadata?.line_user_id,
          display_name: authUser.user_metadata?.display_name,
          picture_url: authUser.user_metadata?.picture_url,
          last_login: new Date().toISOString()
        }, {
          onConflict: 'line_user_id'
        });

      if (error) console.error('ç”¨æˆ¶è³‡æ–™åŒæ­¥å¤±æ•—:', error);
    } catch (error) {
      console.error('åŒæ­¥éŒ¯èª¤:', error);
    }
  };

  return {
    user,
    session,
    loading,
    signInWithLineToken,
    signOut: () => supabase.auth.signOut()
  };
}
```

### 3. API å®‰å…¨ä¸­é–“ä»¶

**Edge Functions å®‰å…¨æª¢æŸ¥ï¼š**
```typescript
// supabase/functions/secure-api/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

serve(async (req) => {
  try {
    // CORS è™•ç†
    if (req.method === 'OPTIONS') {
      return new Response('ok', {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, GET, OPTIONS, DELETE',
          'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
        },
      });
    }

    // é©—è­‰ Authorization header
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'Missing authorization header' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // åˆå§‹åŒ– Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: authHeader },
        },
      }
    );

    // é©—è­‰ç”¨æˆ¶
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Invalid token' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // è™•ç†æ¥­å‹™é‚è¼¯
    const { method, url } = req;
    const urlPath = new URL(url).pathname;

    switch (method) {
      case 'POST':
        if (urlPath.includes('/orders')) {
          return await handleCreateOrder(req, supabaseClient, user);
        }
        break;
      
      case 'GET':
        if (urlPath.includes('/analytics')) {
          return await handleAnalytics(req, supabaseClient, user);
        }
        break;
    }

    return new Response(
      JSON.stringify({ error: 'Not found' }),
      { status: 404, headers: { 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
});

async function handleCreateOrder(req: Request, supabase: any, user: any) {
  const body = await req.json();
  
  // é¡å¤–çš„æ¥­å‹™é‚è¼¯é©—è­‰
  if (!body.store_id || !body.items || body.items.length === 0) {
    return new Response(
      JSON.stringify({ error: 'Invalid order data' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // å‘¼å«è³‡æ–™åº«å‡½æ•¸
  const { data, error } = await supabase.rpc('create_order_transaction', {
    p_user_id: user.id,
    ...body
  });

  if (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  return new Response(
    JSON.stringify({ success: true, data }),
    { status: 200, headers: { 'Content-Type': 'application/json' } }
  );
}
```

---

## ğŸ“Š ç¬¬å…­æ­¥ï¼šåˆ†æèˆ‡ç›£æ§

### 1. æ¥­å‹™åˆ†æå„€è¡¨æ¿

**å»ºç«‹åˆ†ææª¢è¦–ï¼š**
```sql
-- å‰µå»ºæ¥­å‹™åˆ†ææª¢è¦–
CREATE VIEW daily_business_metrics AS
SELECT 
  DATE(created_at) as date,
  COUNT(*) as total_orders,
  SUM(final_amount) as total_revenue,
  AVG(final_amount) as avg_order_value,
  COUNT(DISTINCT user_id) as unique_customers,
  COUNT(*) FILTER (WHERE order_status = 'completed') as completed_orders,
  COUNT(*) FILTER (WHERE order_status = 'cancelled') as cancelled_orders,
  ROUND(
    COUNT(*) FILTER (WHERE order_status = 'completed') * 100.0 / COUNT(*), 2
  ) as completion_rate
FROM orders
WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- ç”¢å“ç†±éŠ·åˆ†æ
CREATE VIEW product_popularity AS
SELECT 
  p.name,
  p.category,
  COUNT(oi.product_id) as order_count,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.subtotal) as total_revenue,
  AVG(p.rating) as avg_rating
FROM products p
JOIN (
  SELECT 
    (jsonb_array_elements(order_items)->>'product_id')::UUID as product_id,
    (jsonb_array_elements(order_items)->>'quantity')::INTEGER as quantity,
    (jsonb_array_elements(order_items)->>'subtotal')::DECIMAL as subtotal
  FROM orders 
  WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
    AND order_status = 'completed'
) oi ON p.id = oi.product_id
GROUP BY p.id, p.name, p.category
ORDER BY total_quantity DESC;

-- é–€å¸‚è¡¨ç¾åˆ†æ
CREATE VIEW store_performance AS
SELECT 
  s.name as store_name,
  COUNT(o.id) as total_orders,
  SUM(o.final_amount) as revenue,
  AVG(EXTRACT(EPOCH FROM (o.actual_pickup_time - o.created_at))/60) as avg_fulfillment_minutes,
  COUNT(*) FILTER (WHERE o.order_status = 'completed') as completed_orders,
  ROUND(
    COUNT(*) FILTER (WHERE o.order_status = 'completed') * 100.0 / COUNT(*), 2
  ) as completion_rate
FROM stores s
LEFT JOIN orders o ON s.id = o.store_id
WHERE o.created_at >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY s.id, s.name
ORDER BY revenue DESC;
```

**åˆ†æ API ç«¯é»ï¼š**
```typescript
// services/analyticsService.ts
export class AnalyticsService {
  // å³æ™‚æ¥­å‹™æŒ‡æ¨™
  static async getRealtimeMetrics() {
    const { data, error } = await supabase
      .rpc('get_realtime_business_metrics');
    
    if (error) throw error;
    return data;
  }

  // éŠ·å”®è¶¨å‹¢åˆ†æ
  static async getSalesTrends(days: number = 30) {
    const { data, error } = await supabase
      .from('daily_business_metrics')
      .select('*')
      .gte('date', new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0])
      .order('date', { ascending: true });

    if (error) throw error;
    return data;
  }

  // ç”¢å“è¡¨ç¾åˆ†æ
  static async getProductAnalytics(timeframe: 'week' | 'month' = 'week') {
    const { data, error } = await supabase
      .from('product_popularity')
      .select('*')
      .limit(20);

    if (error) throw error;
    return data;
  }

  // ç”¨æˆ¶è¡Œç‚ºåˆ†æ
  static async getUserBehaviorMetrics() {
    const { data, error } = await supabase
      .rpc('analyze_user_behavior');

    if (error) throw error;
    return data;
  }
}
```

### 2. å³æ™‚ç›£æ§è­¦ç¤º

**ç³»çµ±å¥åº·ç›£æ§ï¼š**
```sql
-- å»ºç«‹ç³»çµ±å¥åº·æª¢æŸ¥å‡½æ•¸
CREATE OR REPLACE FUNCTION system_health_check()
RETURNS JSONB AS $$
DECLARE
  result JSONB;
  failed_orders INTEGER;
  low_stock_products INTEGER;
  high_queue_stores INTEGER;
BEGIN
  -- æª¢æŸ¥å¤±æ•—è¨‚å–®
  SELECT COUNT(*) INTO failed_orders
  FROM orders 
  WHERE order_status = 'failed' 
    AND created_at > NOW() - INTERVAL '1 hour';

  -- æª¢æŸ¥ä½åº«å­˜å•†å“
  SELECT COUNT(*) INTO low_stock_products
  FROM products 
  WHERE stock_quantity <= low_stock_threshold 
    AND availability_status = true;

  -- æª¢æŸ¥æ’éšŠéé•·çš„é–€å¸‚
  SELECT COUNT(*) INTO high_queue_stores
  FROM stores 
  WHERE current_queue_count > max_concurrent_orders * 0.9;

  result := jsonb_build_object(
    'timestamp', NOW(),
    'status', CASE 
      WHEN failed_orders > 5 OR low_stock_products > 10 OR high_queue_stores > 0 
      THEN 'warning'
      ELSE 'healthy'
    END,
    'metrics', jsonb_build_object(
      'failed_orders_last_hour', failed_orders,
      'low_stock_products', low_stock_products,
      'congested_stores', high_queue_stores
    )
  );

  RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### 3. æ•ˆèƒ½ç›£æ§

**æŸ¥è©¢æ•ˆèƒ½å„ªåŒ–ï¼š**
```sql
-- å»ºç«‹æ•ˆèƒ½ç›£æ§æª¢è¦–
CREATE VIEW slow_queries AS
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  rows
FROM pg_stat_statements 
WHERE mean_time > 100 -- è¶…é 100ms çš„æŸ¥è©¢
ORDER BY mean_time DESC;

-- è³‡æ–™åº«é€£æ¥ç›£æ§
CREATE VIEW connection_stats AS
SELECT 
  datname,
  numbackends,
  xact_commit,
  xact_rollback,
  blks_read,
  blks_hit,
  tup_returned,
  tup_fetched,
  tup_inserted,
  tup_updated,
  tup_deleted
FROM pg_stat_database 
WHERE datname = current_database();
```

---

## ğŸ’° ç¬¬ä¸ƒæ­¥ï¼šæˆæœ¬æ•ˆç›Šèˆ‡éƒ¨ç½²

### 1. Supabase å®šåƒ¹åˆ†æ

<SupabasePricingTable />

### 2. ä¸‰å¹³å°æˆæœ¬æ¯”è¼ƒ

<ThreePlatformCostComparison />

### 3. éƒ¨ç½²ç­–ç•¥

**å¤šç’°å¢ƒéƒ¨ç½²ï¼š**
```bash
# é–‹ç™¼ç’°å¢ƒ
supabase start # æœ¬åœ°é–‹ç™¼
supabase db reset # é‡ç½®è³‡æ–™åº«
supabase db push # æ¨é€ schema è®Šæ›´

# æ¸¬è©¦ç’°å¢ƒ
supabase link --project-ref staging-project
supabase db push --linked # æ¨é€åˆ°é ç«¯

# ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²
supabase link --project-ref production-project
supabase db push --linked --confirm

# è³‡æ–™é·ç§»
supabase db dump --linked > backup.sql
supabase db reset --linked
psql -d postgres://... -f backup.sql
```

**Edge Functions éƒ¨ç½²ï¼š**
```bash
# éƒ¨ç½² Edge Functions
supabase functions deploy order-processor
supabase functions deploy analytics-cron
supabase functions deploy notification-handler

# è¨­å®šç’°å¢ƒè®Šæ•¸
supabase secrets set LINE_CHANNEL_SECRET=your_secret
supabase secrets set NOTIFICATION_WEBHOOK=your_webhook
```

---

## ğŸ† å°ˆæ¡ˆæˆæœç¸½çµ

### æŠ€è¡“æˆæœå°æ¯”

**âœ… Supabase å¯¦ç¾åŠŸèƒ½ï¼š**
- å®Œæ•´çš„ PostgreSQL é—œè¯å¼è³‡æ–™åº«
- è‡ªå‹•ç”Ÿæˆçš„ RESTful API (20+ ç«¯é»)
- å³æ™‚ WebSocket é€£æ¥ï¼ˆè¨‚å–®ã€åº«å­˜ã€æ’éšŠç‹€æ³ï¼‰
- Row Level Security ç´°ç²’åº¦æ¬Šé™æ§åˆ¶
- Edge Functions è‡ªå®šç¾©æ¥­å‹™é‚è¼¯
- å³æ™‚åˆ†æèˆ‡ç›£æ§å„€è¡¨æ¿
- å¤šç’°å¢ƒé–‹ç™¼éƒ¨ç½²æµç¨‹
- é–‹æºç”Ÿæ…‹ç³»çµ±æ•´åˆ

### ä¸‰å¹³å°é—œéµå°æ¯”

<FinalComparisonMatrix />

### Supabase çš„æ±ºå®šæ€§å„ªå‹¢

**ğŸ”“ é–‹æºç”Ÿæ…‹ç³»çµ±ï¼š**
- é¿å…å» å•†é–å®šï¼Œæ°¸ä¹…æ•¸æ“šæ§åˆ¶æ¬Š
- å¯è‡ªéƒ¨ç½²ï¼Œå®Œå…¨è‡ªä¸»æŒæ§
- æ´»èºç¤¾ç¾¤ï¼ŒæŒçºŒåŠŸèƒ½å¢å¼·

**âš¡ å³æ™‚èƒ½åŠ›é ˜å…ˆï¼š**
- åŸç”Ÿ WebSocket æ”¯æ´ï¼Œç„¡éœ€é¡å¤–é…ç½®
- æ¯«ç§’ç´šè³‡æ–™åŒæ­¥ï¼Œç”¨æˆ¶é«”é©—æœ€ä½³
- è¤‡é›œå³æ™‚æ¥­å‹™é‚è¼¯å¯¦ç¾èƒ½åŠ›

**ğŸ›¡ï¸ ä¼æ¥­ç´šå®‰å…¨ï¼š**
- PostgreSQL åŸç”Ÿå®‰å…¨ç‰¹æ€§
- Row Level Security ç´°ç²’åº¦æ§åˆ¶
- å¤šé‡èªè­‰æ•´åˆèƒ½åŠ›

**ğŸ’° æˆæœ¬æ•ˆç›Šæœ€å„ªï¼š**
- å…è²»é¡åº¦ï¼š100GB è³‡æ–™åº« + 500MB å„²å­˜
- ä»˜è²»æ–¹æ¡ˆï¼š$25/æœˆèµ·ï¼Œæ¯” Xano ä¾¿å®œ 40%
- éš¨ç”¨é‡å½ˆæ€§è¨ˆè²»ï¼Œé¿å…å›ºå®šæˆæœ¬æµªè²»

### å¯¦éš›æ¥­å‹™åƒ¹å€¼

**é–‹ç™¼æ•ˆç‡æå‡ï¼š**
- æ¯” Bubble å¿« 50%ï¼ˆ1.5 é€± vs 3 é€±ï¼‰
- æ¯”å‚³çµ±é–‹ç™¼å¿« 75%ï¼ˆ1.5 é€± vs 6 é€±ï¼‰
- é›¶ç¶­è­·è² æ“”ï¼Œå°ˆæ³¨æ¥­å‹™é‚è¼¯

**æŠ€è¡“å‚µå‹™æ§åˆ¶ï¼š**
- æ¨™æº– SQL + TypeScriptï¼Œåœ˜éšŠç„¡å­¸ç¿’æˆæœ¬
- å®Œæ•´ç‰ˆæœ¬æ§åˆ¶ï¼Œä»£ç¢¼å“è³ªå¯æ§
- é–‹æºä¿éšœï¼Œæ°¸ç„¡å¹³å°é¢¨éšª

**æ“´å±•æ€§ä¿è­‰ï¼š**
- æ”¯æ´ 100,000+ ä¸¦ç™¼ç”¨æˆ¶
- å¯ç„¡ç¸«é·ç§»åˆ°è‡ªéƒ¨ç½²ç’°å¢ƒ
- åœ‹éš›åŒ–éƒ¨ç½²èƒ½åŠ›

---

## ğŸ¯ æœ€ä½³å¯¦è¸å»ºè­°

### é–‹ç™¼æµç¨‹å»ºè­°

**1. æœ¬åœ°å„ªå…ˆé–‹ç™¼ï¼š**
```bash
# å®Œæ•´æœ¬åœ°é–‹ç™¼ç’°å¢ƒ
supabase start
supabase db reset
supabase db push
supabase functions serve

# é–‹ç™¼å®Œæˆå¾Œæ¨é€
supabase db push --linked
supabase functions deploy
```

**2. æ¼¸é€²å¼é·ç§»ç­–ç•¥ï¼š**
```typescript
// éšæ®µä¸€ï¼šæ ¸å¿ƒåŠŸèƒ½
- ç”¨æˆ¶ç®¡ç† + å•†å“ç›®éŒ„
- åŸºæœ¬è¨‚å–®æµç¨‹

// éšæ®µäºŒï¼šå³æ™‚åŠŸèƒ½  
- è¨‚å–®ç‹€æ…‹å³æ™‚æ›´æ–°
- åº«å­˜å³æ™‚åŒæ­¥

// éšæ®µä¸‰ï¼šé€²éšåŠŸèƒ½
- æ™ºæ…§åˆ†æå„€è¡¨æ¿
- å€‹äººåŒ–æ¨è–¦ç³»çµ±
```

**3. ç›£æ§èˆ‡å„ªåŒ–ï¼š**
```sql
-- å®šæœŸæ•ˆèƒ½æª¢æŸ¥
SELECT * FROM slow_queries WHERE mean_time > 100;

-- ç´¢å¼•å„ªåŒ–å»ºè­°
SELECT * FROM pg_stat_user_indexes WHERE idx_scan < 50;

-- è³‡æ–™åº«å¤§å°ç›£æ§
SELECT pg_size_pretty(pg_database_size(current_database()));
```

### åœ˜éšŠå”ä½œå»ºè­°

**è§’è‰²åˆ†å·¥ï¼š**
- **å…¨ç«¯é–‹ç™¼**ï¼šSupabase + React LIFF æ•´åˆ
- **è³‡æ–™åº«è¨­è¨ˆå¸«**ï¼šPostgreSQL schema è¨­è¨ˆèˆ‡å„ªåŒ–
- **DevOps å·¥ç¨‹å¸«**ï¼šCI/CD èˆ‡å¤šç’°å¢ƒç®¡ç†
- **æ¥­å‹™åˆ†æå¸«**ï¼šSQL æŸ¥è©¢èˆ‡åˆ†æå„€è¡¨æ¿

---

## ğŸ“ å­¸ç¿’è³‡æºèˆ‡ç¤¾ç¾¤

### Supabase å®˜æ–¹è³‡æº

**å­¸ç¿’å¹³å°ï¼š**
- [Supabase å®˜æ–¹æ–‡æª”](https://supabase.com/docs) - å®Œæ•´æŠ€è¡“æŒ‡å—
- [Supabase University](https://supabase.com/learn) - å…è²»å½±ç‰‡èª²ç¨‹
- [Supabase Blog](https://supabase.com/blog) - æœ€æ–°åŠŸèƒ½èˆ‡æœ€ä½³å¯¦è¸

**é–‹ç™¼å·¥å…·ï¼š**
- [Supabase CLI](https://supabase.com/docs/guides/cli) - æœ¬åœ°é–‹ç™¼å·¥å…·
- [Supabase Studio](https://supabase.com/dashboard) - è¦–è¦ºåŒ–ç®¡ç†ä»‹é¢
- [Template Gallery](https://supabase.com/templates) - å°ˆæ¡ˆæ¨¡æ¿åº«

### ä¸­æ–‡å­¸ç¿’ç¤¾ç¾¤

**æ¨è–¦ç¤¾ç¾¤ï¼š**
- **Supabase å°ç£é–‹ç™¼è€…** - Discord ç¤¾ç¾¤
- **PostgreSQL å°ç£ä½¿ç”¨è€…ç¾¤çµ„** - Facebook ç¤¾åœ˜
- **å…¨ç«¯é–‹ç™¼è€…è¯ç›Ÿ** - Telegram ç¾¤çµ„

---

## ğŸµ çµèªèˆ‡é¸æ“‡å»ºè­°

ç¶“éä¸‰ç¯‡å®Œæ•´çš„å¯¦ä½œæŒ‡å—åˆ†æï¼Œæˆ‘å€‘ç‚º"èŒ¶èªæ™‚å…‰"ç³»çµ±æä¾›äº†ä¸‰ç¨®æˆªç„¶ä¸åŒçš„å¾Œç«¯è§£æ±ºæ–¹æ¡ˆï¼š

### ğŸ¯ é¸æ“‡æ±ºç­–çŸ©é™£

**å¦‚æœä½ æ˜¯...**

**ğŸ“± å¿«é€Ÿé©—è­‰ MVP (é¸æ“‡ Bubble.io)ï¼š**
- éæŠ€è¡“èƒŒæ™¯å‰µæ¥­è€…
- éœ€è¦åœ¨ 3 é€±å…§å®ŒæˆåŸå‹
- é ç®—æœ‰é™ï¼Œåœ˜éšŠ < 3 äºº
- ç”¨æˆ¶é‡é æœŸ < 1,000 äºº

**ğŸ¢ ä¸­å‹ä¼æ¥­æ‡‰ç”¨ (é¸æ“‡ Xano)ï¼š**
- æœ‰åŸºç¤æŠ€è¡“åœ˜éšŠ
- éœ€è¦å°ˆæ¥­ç´š API è¨­è¨ˆ
- é æœŸç”¨æˆ¶é‡ 5,000-50,000 äºº
- é‡è¦–é–‹ç™¼æ•ˆç‡èˆ‡æˆæœ¬æ§åˆ¶

**ğŸš€ ä¼æ¥­ç´šé•·æœŸç™¼å±• (é¸æ“‡ Supabase)ï¼š**
- æŠ€è¡“åœ˜éšŠå…·å‚™ SQL èƒ½åŠ›
- éœ€è¦å³æ™‚åŠŸèƒ½èˆ‡é«˜ä½µç™¼
- é æœŸç”¨æˆ¶é‡ 50,000+ äºº
- é‡è¦–é–‹æºç”Ÿæ…‹èˆ‡é¿å…å» å•†é–å®š

### ğŸ† Supabase çš„å‹å‡ºç†ç”±

åœ¨"èŒ¶èªæ™‚å…‰"é€™æ¨£çš„èŒ¶é£²é ç´„ç³»çµ±ä¸­ï¼Œ**Supabase å±•ç¾äº†æœ€ä½³çš„æ•´é«”åƒ¹å€¼**ï¼š

- **å³æ™‚è¨‚å–®è¿½è¹¤**ï¼šåŸç”Ÿ WebSocket å®Œç¾æ”¯æ´
- **è¤‡é›œå•†æ¥­é‚è¼¯**ï¼šPostgreSQL å‡½æ•¸ + Edge Functions
- **æˆæœ¬æ•ˆç›Šæœ€å„ª**ï¼šå…è²»é¡åº¦æ…·æ…¨ï¼Œä»˜è²»æ–¹æ¡ˆåˆç†
- **æŠ€è¡“å‚µå‹™æœ€ä½**ï¼šæ¨™æº–åŒ–æŠ€è¡“æ£§ï¼Œé›¶å­¸ç¿’æˆæœ¬
- **æœªä¾†æ“´å±•æ€§**ï¼šé–‹æºä¿éšœï¼Œæ°¸ç„¡å¹³å°é¢¨éšª

### ğŸŒŸ æœ€çµ‚å»ºè­°

å°æ–¼"èŒ¶èªæ™‚å…‰"é€™æ¨£çš„ç¾ä»£åŒ–èŒ¶é£²é ç´„ç³»çµ±ï¼Œ**Supabase æä¾›äº†æœ€å¹³è¡¡çš„è§£æ±ºæ–¹æ¡ˆ**ï¼Œçµåˆäº†ï¼š
- Bubble çš„é–‹ç™¼æ•ˆç‡
- Xano çš„å°ˆæ¥­æ¶æ§‹  
- åŠ ä¸Šç¨æœ‰çš„å³æ™‚èƒ½åŠ›èˆ‡é–‹æºå„ªå‹¢

**ğŸš€ ç«‹å³é–‹å§‹ä½ çš„ Supabase ä¹‹æ—…ï¼Œæ‰“é€ ä¸‹ä¸€ä»£å³æ™‚äº’å‹•çš„æ•¸ä½èŒ¶é£²é«”é©—ï¼**

---

*æœ¬æŒ‡å—åŸºæ–¼ Supabase æœ€æ–°åŠŸèƒ½èˆ‡ä¼æ¥­ç´šæœ€ä½³å¯¦è¸ï¼Œæä¾›å¯ç›´æ¥æ‡‰ç”¨æ–¼ç”Ÿç”¢ç’°å¢ƒçš„å®Œæ•´è§£æ±ºæ–¹æ¡ˆã€‚å¾ MVP åˆ°ä¼æ¥­ç´šæ“´å±•ï¼ŒSupabase å°‡é™ªä¼´ä½ çš„æ¥­å‹™æˆé•·æ¯ä¸€æ­¥ã€‚*